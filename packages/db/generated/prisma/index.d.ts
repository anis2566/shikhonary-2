
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model ClassName
 * 
 */
export type ClassName = $Result.DefaultSelection<Prisma.$ClassNamePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model ChapterContext
 * 
 */
export type ChapterContext = $Result.DefaultSelection<Prisma.$ChapterContextPayload>
/**
 * Model Mcq
 * 
 */
export type Mcq = $Result.DefaultSelection<Prisma.$McqPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model McqAttempt
 * 
 */
export type McqAttempt = $Result.DefaultSelection<Prisma.$McqAttemptPayload>
/**
 * Model ExamFeedback
 * 
 */
export type ExamFeedback = $Result.DefaultSelection<Prisma.$ExamFeedbackPayload>
/**
 * Model CreditPlan
 * 
 */
export type CreditPlan = $Result.DefaultSelection<Prisma.$CreditPlanPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model ExamPlan
 * 
 */
export type ExamPlan = $Result.DefaultSelection<Prisma.$ExamPlanPayload>
/**
 * Model PlanPurchase
 * 
 */
export type PlanPurchase = $Result.DefaultSelection<Prisma.$PlanPurchasePayload>
/**
 * Model Refer
 * 
 */
export type Refer = $Result.DefaultSelection<Prisma.$ReferPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Recommendation
 * 
 */
export type Recommendation = $Result.DefaultSelection<Prisma.$RecommendationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.className`: Exposes CRUD operations for the **ClassName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassNames
    * const classNames = await prisma.className.findMany()
    * ```
    */
  get className(): Prisma.ClassNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapterContext`: Exposes CRUD operations for the **ChapterContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterContexts
    * const chapterContexts = await prisma.chapterContext.findMany()
    * ```
    */
  get chapterContext(): Prisma.ChapterContextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mcq`: Exposes CRUD operations for the **Mcq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mcqs
    * const mcqs = await prisma.mcq.findMany()
    * ```
    */
  get mcq(): Prisma.McqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mcqAttempt`: Exposes CRUD operations for the **McqAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more McqAttempts
    * const mcqAttempts = await prisma.mcqAttempt.findMany()
    * ```
    */
  get mcqAttempt(): Prisma.McqAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examFeedback`: Exposes CRUD operations for the **ExamFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamFeedbacks
    * const examFeedbacks = await prisma.examFeedback.findMany()
    * ```
    */
  get examFeedback(): Prisma.ExamFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditPlan`: Exposes CRUD operations for the **CreditPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditPlans
    * const creditPlans = await prisma.creditPlan.findMany()
    * ```
    */
  get creditPlan(): Prisma.CreditPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examPlan`: Exposes CRUD operations for the **ExamPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamPlans
    * const examPlans = await prisma.examPlan.findMany()
    * ```
    */
  get examPlan(): Prisma.ExamPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planPurchase`: Exposes CRUD operations for the **PlanPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanPurchases
    * const planPurchases = await prisma.planPurchase.findMany()
    * ```
    */
  get planPurchase(): Prisma.PlanPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refer`: Exposes CRUD operations for the **Refer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refers
    * const refers = await prisma.refer.findMany()
    * ```
    */
  get refer(): Prisma.ReferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommendation`: Exposes CRUD operations for the **Recommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recommendations
    * const recommendations = await prisma.recommendation.findMany()
    * ```
    */
  get recommendation(): Prisma.RecommendationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Verification: 'Verification',
    ClassName: 'ClassName',
    Subject: 'Subject',
    Chapter: 'Chapter',
    ChapterContext: 'ChapterContext',
    Mcq: 'Mcq',
    Exam: 'Exam',
    McqAttempt: 'McqAttempt',
    ExamFeedback: 'ExamFeedback',
    CreditPlan: 'CreditPlan',
    Transaction: 'Transaction',
    ExamPlan: 'ExamPlan',
    PlanPurchase: 'PlanPurchase',
    Refer: 'Refer',
    Announcement: 'Announcement',
    Recommendation: 'Recommendation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verification" | "className" | "subject" | "chapter" | "chapterContext" | "mcq" | "exam" | "mcqAttempt" | "examFeedback" | "creditPlan" | "transaction" | "examPlan" | "planPurchase" | "refer" | "announcement" | "recommendation"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      ClassName: {
        payload: Prisma.$ClassNamePayload<ExtArgs>
        fields: Prisma.ClassNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findFirst: {
            args: Prisma.ClassNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findMany: {
            args: Prisma.ClassNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          create: {
            args: Prisma.ClassNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          createMany: {
            args: Prisma.ClassNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          update: {
            args: Prisma.ClassNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          deleteMany: {
            args: Prisma.ClassNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          aggregate: {
            args: Prisma.ClassNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassName>
          }
          groupBy: {
            args: Prisma.ClassNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassNameGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClassNameFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClassNameAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClassNameCountArgs<ExtArgs>
            result: $Utils.Optional<ClassNameCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChapterFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChapterAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      ChapterContext: {
        payload: Prisma.$ChapterContextPayload<ExtArgs>
        fields: Prisma.ChapterContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          findFirst: {
            args: Prisma.ChapterContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          findMany: {
            args: Prisma.ChapterContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>[]
          }
          create: {
            args: Prisma.ChapterContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          createMany: {
            args: Prisma.ChapterContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChapterContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          update: {
            args: Prisma.ChapterContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          deleteMany: {
            args: Prisma.ChapterContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChapterContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterContextPayload>
          }
          aggregate: {
            args: Prisma.ChapterContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterContext>
          }
          groupBy: {
            args: Prisma.ChapterContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterContextGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChapterContextFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChapterContextAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChapterContextCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterContextCountAggregateOutputType> | number
          }
        }
      }
      Mcq: {
        payload: Prisma.$McqPayload<ExtArgs>
        fields: Prisma.McqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.McqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.McqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          findFirst: {
            args: Prisma.McqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.McqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          findMany: {
            args: Prisma.McqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>[]
          }
          create: {
            args: Prisma.McqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          createMany: {
            args: Prisma.McqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.McqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          update: {
            args: Prisma.McqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          deleteMany: {
            args: Prisma.McqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.McqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.McqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqPayload>
          }
          aggregate: {
            args: Prisma.McqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMcq>
          }
          groupBy: {
            args: Prisma.McqGroupByArgs<ExtArgs>
            result: $Utils.Optional<McqGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.McqFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.McqAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.McqCountArgs<ExtArgs>
            result: $Utils.Optional<McqCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      McqAttempt: {
        payload: Prisma.$McqAttemptPayload<ExtArgs>
        fields: Prisma.McqAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.McqAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.McqAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          findFirst: {
            args: Prisma.McqAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.McqAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          findMany: {
            args: Prisma.McqAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>[]
          }
          create: {
            args: Prisma.McqAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          createMany: {
            args: Prisma.McqAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.McqAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          update: {
            args: Prisma.McqAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          deleteMany: {
            args: Prisma.McqAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.McqAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.McqAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$McqAttemptPayload>
          }
          aggregate: {
            args: Prisma.McqAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMcqAttempt>
          }
          groupBy: {
            args: Prisma.McqAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<McqAttemptGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.McqAttemptFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.McqAttemptAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.McqAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<McqAttemptCountAggregateOutputType> | number
          }
        }
      }
      ExamFeedback: {
        payload: Prisma.$ExamFeedbackPayload<ExtArgs>
        fields: Prisma.ExamFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          findFirst: {
            args: Prisma.ExamFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          findMany: {
            args: Prisma.ExamFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>[]
          }
          create: {
            args: Prisma.ExamFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          createMany: {
            args: Prisma.ExamFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          update: {
            args: Prisma.ExamFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.ExamFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamFeedbackPayload>
          }
          aggregate: {
            args: Prisma.ExamFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamFeedback>
          }
          groupBy: {
            args: Prisma.ExamFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamFeedbackGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExamFeedbackFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExamFeedbackAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExamFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<ExamFeedbackCountAggregateOutputType> | number
          }
        }
      }
      CreditPlan: {
        payload: Prisma.$CreditPlanPayload<ExtArgs>
        fields: Prisma.CreditPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          findFirst: {
            args: Prisma.CreditPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          findMany: {
            args: Prisma.CreditPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>[]
          }
          create: {
            args: Prisma.CreditPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          createMany: {
            args: Prisma.CreditPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CreditPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          update: {
            args: Prisma.CreditPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          deleteMany: {
            args: Prisma.CreditPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreditPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditPlanPayload>
          }
          aggregate: {
            args: Prisma.CreditPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditPlan>
          }
          groupBy: {
            args: Prisma.CreditPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditPlanGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CreditPlanFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CreditPlanAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CreditPlanCountArgs<ExtArgs>
            result: $Utils.Optional<CreditPlanCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TransactionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TransactionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      ExamPlan: {
        payload: Prisma.$ExamPlanPayload<ExtArgs>
        fields: Prisma.ExamPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          findFirst: {
            args: Prisma.ExamPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          findMany: {
            args: Prisma.ExamPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>[]
          }
          create: {
            args: Prisma.ExamPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          createMany: {
            args: Prisma.ExamPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExamPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          update: {
            args: Prisma.ExamPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          deleteMany: {
            args: Prisma.ExamPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPlanPayload>
          }
          aggregate: {
            args: Prisma.ExamPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamPlan>
          }
          groupBy: {
            args: Prisma.ExamPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamPlanGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExamPlanFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExamPlanAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExamPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ExamPlanCountAggregateOutputType> | number
          }
        }
      }
      PlanPurchase: {
        payload: Prisma.$PlanPurchasePayload<ExtArgs>
        fields: Prisma.PlanPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          findFirst: {
            args: Prisma.PlanPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          findMany: {
            args: Prisma.PlanPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>[]
          }
          create: {
            args: Prisma.PlanPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          createMany: {
            args: Prisma.PlanPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          update: {
            args: Prisma.PlanPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          deleteMany: {
            args: Prisma.PlanPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPurchasePayload>
          }
          aggregate: {
            args: Prisma.PlanPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanPurchase>
          }
          groupBy: {
            args: Prisma.PlanPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanPurchaseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlanPurchaseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlanPurchaseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlanPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PlanPurchaseCountAggregateOutputType> | number
          }
        }
      }
      Refer: {
        payload: Prisma.$ReferPayload<ExtArgs>
        fields: Prisma.ReferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          findFirst: {
            args: Prisma.ReferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          findMany: {
            args: Prisma.ReferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>[]
          }
          create: {
            args: Prisma.ReferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          createMany: {
            args: Prisma.ReferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          update: {
            args: Prisma.ReferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          deleteMany: {
            args: Prisma.ReferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferPayload>
          }
          aggregate: {
            args: Prisma.ReferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefer>
          }
          groupBy: {
            args: Prisma.ReferGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReferFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReferAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReferCountArgs<ExtArgs>
            result: $Utils.Optional<ReferCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AnnouncementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AnnouncementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Recommendation: {
        payload: Prisma.$RecommendationPayload<ExtArgs>
        fields: Prisma.RecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findFirst: {
            args: Prisma.RecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findMany: {
            args: Prisma.RecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          create: {
            args: Prisma.RecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          createMany: {
            args: Prisma.RecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          update: {
            args: Prisma.RecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          deleteMany: {
            args: Prisma.RecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          aggregate: {
            args: Prisma.RecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendation>
          }
          groupBy: {
            args: Prisma.RecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RecommendationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RecommendationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verification?: VerificationOmit
    className?: ClassNameOmit
    subject?: SubjectOmit
    chapter?: ChapterOmit
    chapterContext?: ChapterContextOmit
    mcq?: McqOmit
    exam?: ExamOmit
    mcqAttempt?: McqAttemptOmit
    examFeedback?: ExamFeedbackOmit
    creditPlan?: CreditPlanOmit
    transaction?: TransactionOmit
    examPlan?: ExamPlanOmit
    planPurchase?: PlanPurchaseOmit
    refer?: ReferOmit
    announcement?: AnnouncementOmit
    recommendation?: RecommendationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    exams: number
    attempts: number
    feedbacks: number
    transactions: number
    purchases: number
    referredByMe: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    exams?: boolean | UserCountOutputTypeCountExamsArgs
    attempts?: boolean | UserCountOutputTypeCountAttemptsArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    referredByMe?: boolean | UserCountOutputTypeCountReferredByMeArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferredByMeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferWhereInput
  }


  /**
   * Count Type ClassNameCountOutputType
   */

  export type ClassNameCountOutputType = {
    subjects: number
    chapters: number
    exams: number
  }

  export type ClassNameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | ClassNameCountOutputTypeCountSubjectsArgs
    chapters?: boolean | ClassNameCountOutputTypeCountChaptersArgs
    exams?: boolean | ClassNameCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * ClassNameCountOutputType without action
   */
  export type ClassNameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassNameCountOutputType
     */
    select?: ClassNameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassNameCountOutputType without action
   */
  export type ClassNameCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * ClassNameCountOutputType without action
   */
  export type ClassNameCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * ClassNameCountOutputType without action
   */
  export type ClassNameCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    classNames: number
    chapters: number
    mcqs: number
    exams: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classNames?: boolean | SubjectCountOutputTypeCountClassNamesArgs
    chapters?: boolean | SubjectCountOutputTypeCountChaptersArgs
    mcqs?: boolean | SubjectCountOutputTypeCountMcqsArgs
    exams?: boolean | SubjectCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountMcqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    exams: number
    classNames: number
    mcqs: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | ChapterCountOutputTypeCountExamsArgs
    classNames?: boolean | ChapterCountOutputTypeCountClassNamesArgs
    mcqs?: boolean | ChapterCountOutputTypeCountMcqsArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountClassNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountMcqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqWhereInput
  }


  /**
   * Count Type McqCountOutputType
   */

  export type McqCountOutputType = {
    exams: number
  }

  export type McqCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | McqCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * McqCountOutputType without action
   */
  export type McqCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqCountOutputType
     */
    select?: McqCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * McqCountOutputType without action
   */
  export type McqCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    chapters: number
    questions: number
    attempts: number
    recommendations: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | ExamCountOutputTypeCountChaptersArgs
    questions?: boolean | ExamCountOutputTypeCountQuestionsArgs
    attempts?: boolean | ExamCountOutputTypeCountAttemptsArgs
    recommendations?: boolean | ExamCountOutputTypeCountRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqAttemptWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
  }


  /**
   * Count Type CreditPlanCountOutputType
   */

  export type CreditPlanCountOutputType = {
    transactions: number
  }

  export type CreditPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CreditPlanCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CreditPlanCountOutputType without action
   */
  export type CreditPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlanCountOutputType
     */
    select?: CreditPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreditPlanCountOutputType without action
   */
  export type CreditPlanCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ExamPlanCountOutputType
   */

  export type ExamPlanCountOutputType = {
    purchases: number
  }

  export type ExamPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ExamPlanCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * ExamPlanCountOutputType without action
   */
  export type ExamPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlanCountOutputType
     */
    select?: ExamPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamPlanCountOutputType without action
   */
  export type ExamPlanCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPurchaseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: string | null
    status: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: string | null
    status: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    role: number
    status: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    status?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    status?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    status?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: boolean
    image: string | null
    role: string
    status: string
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referredToMe?: boolean | User$referredToMeArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    referredByMe?: boolean | User$referredByMeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "role" | "status" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredToMe?: boolean | User$referredToMeArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    attempts?: boolean | User$attemptsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    referredByMe?: boolean | User$referredByMeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      referredToMe: Prisma.$ReferPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      attempts: Prisma.$McqAttemptPayload<ExtArgs>[]
      feedbacks: Prisma.$ExamFeedbackPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      purchases: Prisma.$PlanPurchasePayload<ExtArgs>[]
      referredByMe: Prisma.$ReferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: boolean
      image: string | null
      role: string
      status: string
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referredToMe<T extends User$referredToMeArgs<ExtArgs> = {}>(args?: Subset<T, User$referredToMeArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends User$examsArgs<ExtArgs> = {}>(args?: Subset<T, User$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends User$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referredByMe<T extends User$referredByMeArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByMeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.referredToMe
   */
  export type User$referredToMeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    where?: ReferWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.exams
   */
  export type User$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * User.attempts
   */
  export type User$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    where?: McqAttemptWhereInput
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    cursor?: McqAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: McqAttemptScalarFieldEnum | McqAttemptScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    where?: ExamFeedbackWhereInput
    orderBy?: ExamFeedbackOrderByWithRelationInput | ExamFeedbackOrderByWithRelationInput[]
    cursor?: ExamFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamFeedbackScalarFieldEnum | ExamFeedbackScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    where?: PlanPurchaseWhereInput
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    cursor?: PlanPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanPurchaseScalarFieldEnum | PlanPurchaseScalarFieldEnum[]
  }

  /**
   * User.referredByMe
   */
  export type User$referredByMeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    where?: ReferWhereInput
    orderBy?: ReferOrderByWithRelationInput | ReferOrderByWithRelationInput[]
    cursor?: ReferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferScalarFieldEnum | ReferScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    expiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    expiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    expiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    expiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "expiresAt" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      expiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>



  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * @param {VerificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verification = await prisma.verification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VerificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Verification.
     * @param {VerificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verification = await prisma.verification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VerificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification findRaw
   */
  export type VerificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Verification aggregateRaw
   */
  export type VerificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model ClassName
   */

  export type AggregateClassName = {
    _count: ClassNameCountAggregateOutputType | null
    _avg: ClassNameAvgAggregateOutputType | null
    _sum: ClassNameSumAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  export type ClassNameAvgAggregateOutputType = {
    position: number | null
  }

  export type ClassNameSumAggregateOutputType = {
    position: number | null
  }

  export type ClassNameMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassNameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassNameCountAggregateOutputType = {
    id: number
    name: number
    level: number
    position: number
    subjectIds: number
    chapterIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassNameAvgAggregateInputType = {
    position?: true
  }

  export type ClassNameSumAggregateInputType = {
    position?: true
  }

  export type ClassNameMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassNameMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassNameCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    position?: true
    subjectIds?: true
    chapterIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassName to aggregate.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassNames
    **/
    _count?: true | ClassNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassNameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassNameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassNameMaxAggregateInputType
  }

  export type GetClassNameAggregateType<T extends ClassNameAggregateArgs> = {
        [P in keyof T & keyof AggregateClassName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassName[P]>
      : GetScalarType<T[P], AggregateClassName[P]>
  }




  export type ClassNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithAggregationInput | ClassNameOrderByWithAggregationInput[]
    by: ClassNameScalarFieldEnum[] | ClassNameScalarFieldEnum
    having?: ClassNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassNameCountAggregateInputType | true
    _avg?: ClassNameAvgAggregateInputType
    _sum?: ClassNameSumAggregateInputType
    _min?: ClassNameMinAggregateInputType
    _max?: ClassNameMaxAggregateInputType
  }

  export type ClassNameGroupByOutputType = {
    id: string
    name: string
    level: string
    position: number
    subjectIds: string[]
    chapterIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: ClassNameCountAggregateOutputType | null
    _avg: ClassNameAvgAggregateOutputType | null
    _sum: ClassNameSumAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  type GetClassNameGroupByPayload<T extends ClassNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
            : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
        }
      >
    >


  export type ClassNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    position?: boolean
    subjectIds?: boolean
    chapterIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subjects?: boolean | ClassName$subjectsArgs<ExtArgs>
    chapters?: boolean | ClassName$chaptersArgs<ExtArgs>
    exams?: boolean | ClassName$examsArgs<ExtArgs>
    _count?: boolean | ClassNameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>



  export type ClassNameSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    position?: boolean
    subjectIds?: boolean
    chapterIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level" | "position" | "subjectIds" | "chapterIds" | "createdAt" | "updatedAt", ExtArgs["result"]["className"]>
  export type ClassNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | ClassName$subjectsArgs<ExtArgs>
    chapters?: boolean | ClassName$chaptersArgs<ExtArgs>
    exams?: boolean | ClassName$examsArgs<ExtArgs>
    _count?: boolean | ClassNameCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassName"
    objects: {
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: string
      position: number
      subjectIds: string[]
      chapterIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["className"]>
    composites: {}
  }

  type ClassNameGetPayload<S extends boolean | null | undefined | ClassNameDefaultArgs> = $Result.GetResult<Prisma.$ClassNamePayload, S>

  type ClassNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassNameCountAggregateInputType | true
    }

  export interface ClassNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassName'], meta: { name: 'ClassName' } }
    /**
     * Find zero or one ClassName that matches the filter.
     * @param {ClassNameFindUniqueArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassNameFindUniqueArgs>(args: SelectSubset<T, ClassNameFindUniqueArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassNameFindUniqueOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassNameFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassNameFindFirstArgs>(args?: SelectSubset<T, ClassNameFindFirstArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassNameFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassNames
     * const classNames = await prisma.className.findMany()
     * 
     * // Get first 10 ClassNames
     * const classNames = await prisma.className.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classNameWithIdOnly = await prisma.className.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassNameFindManyArgs>(args?: SelectSubset<T, ClassNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassName.
     * @param {ClassNameCreateArgs} args - Arguments to create a ClassName.
     * @example
     * // Create one ClassName
     * const ClassName = await prisma.className.create({
     *   data: {
     *     // ... data to create a ClassName
     *   }
     * })
     * 
     */
    create<T extends ClassNameCreateArgs>(args: SelectSubset<T, ClassNameCreateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassNames.
     * @param {ClassNameCreateManyArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassNameCreateManyArgs>(args?: SelectSubset<T, ClassNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassName.
     * @param {ClassNameDeleteArgs} args - Arguments to delete one ClassName.
     * @example
     * // Delete one ClassName
     * const ClassName = await prisma.className.delete({
     *   where: {
     *     // ... filter to delete one ClassName
     *   }
     * })
     * 
     */
    delete<T extends ClassNameDeleteArgs>(args: SelectSubset<T, ClassNameDeleteArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassName.
     * @param {ClassNameUpdateArgs} args - Arguments to update one ClassName.
     * @example
     * // Update one ClassName
     * const className = await prisma.className.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassNameUpdateArgs>(args: SelectSubset<T, ClassNameUpdateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassNames.
     * @param {ClassNameDeleteManyArgs} args - Arguments to filter ClassNames to delete.
     * @example
     * // Delete a few ClassNames
     * const { count } = await prisma.className.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassNameDeleteManyArgs>(args?: SelectSubset<T, ClassNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassNameUpdateManyArgs>(args: SelectSubset<T, ClassNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassName.
     * @param {ClassNameUpsertArgs} args - Arguments to update or create a ClassName.
     * @example
     * // Update or create a ClassName
     * const className = await prisma.className.upsert({
     *   create: {
     *     // ... data to create a ClassName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassName we want to update
     *   }
     * })
     */
    upsert<T extends ClassNameUpsertArgs>(args: SelectSubset<T, ClassNameUpsertArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassNames that matches the filter.
     * @param {ClassNameFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const className = await prisma.className.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClassNameFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClassName.
     * @param {ClassNameAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const className = await prisma.className.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClassNameAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameCountArgs} args - Arguments to filter ClassNames to count.
     * @example
     * // Count the number of ClassNames
     * const count = await prisma.className.count({
     *   where: {
     *     // ... the filter for the ClassNames we want to count
     *   }
     * })
    **/
    count<T extends ClassNameCountArgs>(
      args?: Subset<T, ClassNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassNameAggregateArgs>(args: Subset<T, ClassNameAggregateArgs>): Prisma.PrismaPromise<GetClassNameAggregateType<T>>

    /**
     * Group by ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassNameGroupByArgs['orderBy'] }
        : { orderBy?: ClassNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassName model
   */
  readonly fields: ClassNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subjects<T extends ClassName$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, ClassName$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapters<T extends ClassName$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, ClassName$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends ClassName$examsArgs<ExtArgs> = {}>(args?: Subset<T, ClassName$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassName model
   */
  interface ClassNameFieldRefs {
    readonly id: FieldRef<"ClassName", 'String'>
    readonly name: FieldRef<"ClassName", 'String'>
    readonly level: FieldRef<"ClassName", 'String'>
    readonly position: FieldRef<"ClassName", 'Int'>
    readonly subjectIds: FieldRef<"ClassName", 'String[]'>
    readonly chapterIds: FieldRef<"ClassName", 'String[]'>
    readonly createdAt: FieldRef<"ClassName", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassName", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassName findUnique
   */
  export type ClassNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findUniqueOrThrow
   */
  export type ClassNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findFirst
   */
  export type ClassNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findFirstOrThrow
   */
  export type ClassNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findMany
   */
  export type ClassNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassNames to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName create
   */
  export type ClassNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassName.
     */
    data: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
  }

  /**
   * ClassName createMany
   */
  export type ClassNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
  }

  /**
   * ClassName update
   */
  export type ClassNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassName.
     */
    data: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
    /**
     * Choose, which ClassName to update.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName updateMany
   */
  export type ClassNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
  }

  /**
   * ClassName upsert
   */
  export type ClassNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassName to update in case it exists.
     */
    where: ClassNameWhereUniqueInput
    /**
     * In case the ClassName found by the `where` argument doesn't exist, create a new ClassName with this data.
     */
    create: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
    /**
     * In case the ClassName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
  }

  /**
   * ClassName delete
   */
  export type ClassNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter which ClassName to delete.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName deleteMany
   */
  export type ClassNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassNames to delete
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to delete.
     */
    limit?: number
  }

  /**
   * ClassName findRaw
   */
  export type ClassNameFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClassName aggregateRaw
   */
  export type ClassNameAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ClassName.subjects
   */
  export type ClassName$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * ClassName.chapters
   */
  export type ClassName$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * ClassName.exams
   */
  export type ClassName$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * ClassName without action
   */
  export type ClassNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    group: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    group: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    group: number
    classNameIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    group?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    group?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    group?: true
    classNameIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    group: string | null
    classNameIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    group?: boolean
    classNameIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classNames?: boolean | Subject$classNamesArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    mcqs?: boolean | Subject$mcqsArgs<ExtArgs>
    exams?: boolean | Subject$examsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    group?: boolean
    classNameIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "group" | "classNameIds" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classNames?: boolean | Subject$classNamesArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    mcqs?: boolean | Subject$mcqsArgs<ExtArgs>
    exams?: boolean | Subject$examsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      classNames: Prisma.$ClassNamePayload<ExtArgs>[]
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      mcqs: Prisma.$McqPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      group: string | null
      classNameIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * @param {SubjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subject = await prisma.subject.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SubjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subject.
     * @param {SubjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subject = await prisma.subject.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classNames<T extends Subject$classNamesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classNamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapters<T extends Subject$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mcqs<T extends Subject$mcqsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$mcqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends Subject$examsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly group: FieldRef<"Subject", 'String'>
    readonly classNameIds: FieldRef<"Subject", 'String[]'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject findRaw
   */
  export type SubjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject aggregateRaw
   */
  export type SubjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject.classNames
   */
  export type Subject$classNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    cursor?: ClassNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * Subject.chapters
   */
  export type Subject$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Subject.mcqs
   */
  export type Subject$mcqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    where?: McqWhereInput
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    cursor?: McqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Subject.exams
   */
  export type Subject$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    position: number | null
  }

  export type ChapterSumAggregateOutputType = {
    position: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    name: string | null
    position: number | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    position: number | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    name: number
    position: number
    subjectId: number
    examIds: number
    classNameIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    position?: true
  }

  export type ChapterSumAggregateInputType = {
    position?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    subjectId?: true
    examIds?: true
    classNameIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    name: string
    position: number
    subjectId: string
    examIds: string[]
    classNameIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    subjectId?: boolean
    examIds?: boolean
    classNameIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    exams?: boolean | Chapter$examsArgs<ExtArgs>
    classNames?: boolean | Chapter$classNamesArgs<ExtArgs>
    context?: boolean | Chapter$contextArgs<ExtArgs>
    mcqs?: boolean | Chapter$mcqsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>



  export type ChapterSelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    subjectId?: boolean
    examIds?: boolean
    classNameIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "position" | "subjectId" | "examIds" | "classNameIds" | "createdAt" | "updatedAt", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    exams?: boolean | Chapter$examsArgs<ExtArgs>
    classNames?: boolean | Chapter$classNamesArgs<ExtArgs>
    context?: boolean | Chapter$contextArgs<ExtArgs>
    mcqs?: boolean | Chapter$mcqsArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      exams: Prisma.$ExamPayload<ExtArgs>[]
      classNames: Prisma.$ClassNamePayload<ExtArgs>[]
      context: Prisma.$ChapterContextPayload<ExtArgs> | null
      mcqs: Prisma.$McqPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      position: number
      subjectId: string
      examIds: string[]
      classNameIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * @param {ChapterFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chapter = await prisma.chapter.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChapterFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Chapter.
     * @param {ChapterAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chapter = await prisma.chapter.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChapterAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exams<T extends Chapter$examsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classNames<T extends Chapter$classNamesArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$classNamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    context<T extends Chapter$contextArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$contextArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mcqs<T extends Chapter$mcqsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$mcqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly name: FieldRef<"Chapter", 'String'>
    readonly position: FieldRef<"Chapter", 'Int'>
    readonly subjectId: FieldRef<"Chapter", 'String'>
    readonly examIds: FieldRef<"Chapter", 'String[]'>
    readonly classNameIds: FieldRef<"Chapter", 'String[]'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
    readonly updatedAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter findRaw
   */
  export type ChapterFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chapter aggregateRaw
   */
  export type ChapterAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chapter.exams
   */
  export type Chapter$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Chapter.classNames
   */
  export type Chapter$classNamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    cursor?: ClassNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * Chapter.context
   */
  export type Chapter$contextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    where?: ChapterContextWhereInput
  }

  /**
   * Chapter.mcqs
   */
  export type Chapter$mcqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    where?: McqWhereInput
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    cursor?: McqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model ChapterContext
   */

  export type AggregateChapterContext = {
    _count: ChapterContextCountAggregateOutputType | null
    _min: ChapterContextMinAggregateOutputType | null
    _max: ChapterContextMaxAggregateOutputType | null
  }

  export type ChapterContextMinAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    authorSummary: string | null
    content: string | null
    meaning: string | null
    summary: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterContextMaxAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    authorSummary: string | null
    content: string | null
    meaning: string | null
    summary: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterContextCountAggregateOutputType = {
    id: number
    title: number
    author: number
    authorSummary: number
    content: number
    meaning: number
    summary: number
    chapterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChapterContextMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    authorSummary?: true
    content?: true
    meaning?: true
    summary?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterContextMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    authorSummary?: true
    content?: true
    meaning?: true
    summary?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterContextCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    authorSummary?: true
    content?: true
    meaning?: true
    summary?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChapterContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterContext to aggregate.
     */
    where?: ChapterContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterContexts to fetch.
     */
    orderBy?: ChapterContextOrderByWithRelationInput | ChapterContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterContexts
    **/
    _count?: true | ChapterContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterContextMaxAggregateInputType
  }

  export type GetChapterContextAggregateType<T extends ChapterContextAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterContext[P]>
      : GetScalarType<T[P], AggregateChapterContext[P]>
  }




  export type ChapterContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterContextWhereInput
    orderBy?: ChapterContextOrderByWithAggregationInput | ChapterContextOrderByWithAggregationInput[]
    by: ChapterContextScalarFieldEnum[] | ChapterContextScalarFieldEnum
    having?: ChapterContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterContextCountAggregateInputType | true
    _min?: ChapterContextMinAggregateInputType
    _max?: ChapterContextMaxAggregateInputType
  }

  export type ChapterContextGroupByOutputType = {
    id: string
    title: string
    author: string | null
    authorSummary: string | null
    content: string
    meaning: string | null
    summary: string | null
    chapterId: string
    createdAt: Date
    updatedAt: Date
    _count: ChapterContextCountAggregateOutputType | null
    _min: ChapterContextMinAggregateOutputType | null
    _max: ChapterContextMaxAggregateOutputType | null
  }

  type GetChapterContextGroupByPayload<T extends ChapterContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterContextGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterContextGroupByOutputType[P]>
        }
      >
    >


  export type ChapterContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    authorSummary?: boolean
    content?: boolean
    meaning?: boolean
    summary?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterContext"]>



  export type ChapterContextSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    authorSummary?: boolean
    content?: boolean
    meaning?: boolean
    summary?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChapterContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "author" | "authorSummary" | "content" | "meaning" | "summary" | "chapterId" | "createdAt" | "updatedAt", ExtArgs["result"]["chapterContext"]>
  export type ChapterContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $ChapterContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterContext"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      author: string | null
      authorSummary: string | null
      content: string
      meaning: string | null
      summary: string | null
      chapterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapterContext"]>
    composites: {}
  }

  type ChapterContextGetPayload<S extends boolean | null | undefined | ChapterContextDefaultArgs> = $Result.GetResult<Prisma.$ChapterContextPayload, S>

  type ChapterContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterContextCountAggregateInputType | true
    }

  export interface ChapterContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterContext'], meta: { name: 'ChapterContext' } }
    /**
     * Find zero or one ChapterContext that matches the filter.
     * @param {ChapterContextFindUniqueArgs} args - Arguments to find a ChapterContext
     * @example
     * // Get one ChapterContext
     * const chapterContext = await prisma.chapterContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterContextFindUniqueArgs>(args: SelectSubset<T, ChapterContextFindUniqueArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChapterContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterContextFindUniqueOrThrowArgs} args - Arguments to find a ChapterContext
     * @example
     * // Get one ChapterContext
     * const chapterContext = await prisma.chapterContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterContextFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextFindFirstArgs} args - Arguments to find a ChapterContext
     * @example
     * // Get one ChapterContext
     * const chapterContext = await prisma.chapterContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterContextFindFirstArgs>(args?: SelectSubset<T, ChapterContextFindFirstArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChapterContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextFindFirstOrThrowArgs} args - Arguments to find a ChapterContext
     * @example
     * // Get one ChapterContext
     * const chapterContext = await prisma.chapterContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterContextFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChapterContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterContexts
     * const chapterContexts = await prisma.chapterContext.findMany()
     * 
     * // Get first 10 ChapterContexts
     * const chapterContexts = await prisma.chapterContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterContextWithIdOnly = await prisma.chapterContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterContextFindManyArgs>(args?: SelectSubset<T, ChapterContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChapterContext.
     * @param {ChapterContextCreateArgs} args - Arguments to create a ChapterContext.
     * @example
     * // Create one ChapterContext
     * const ChapterContext = await prisma.chapterContext.create({
     *   data: {
     *     // ... data to create a ChapterContext
     *   }
     * })
     * 
     */
    create<T extends ChapterContextCreateArgs>(args: SelectSubset<T, ChapterContextCreateArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChapterContexts.
     * @param {ChapterContextCreateManyArgs} args - Arguments to create many ChapterContexts.
     * @example
     * // Create many ChapterContexts
     * const chapterContext = await prisma.chapterContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterContextCreateManyArgs>(args?: SelectSubset<T, ChapterContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChapterContext.
     * @param {ChapterContextDeleteArgs} args - Arguments to delete one ChapterContext.
     * @example
     * // Delete one ChapterContext
     * const ChapterContext = await prisma.chapterContext.delete({
     *   where: {
     *     // ... filter to delete one ChapterContext
     *   }
     * })
     * 
     */
    delete<T extends ChapterContextDeleteArgs>(args: SelectSubset<T, ChapterContextDeleteArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChapterContext.
     * @param {ChapterContextUpdateArgs} args - Arguments to update one ChapterContext.
     * @example
     * // Update one ChapterContext
     * const chapterContext = await prisma.chapterContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterContextUpdateArgs>(args: SelectSubset<T, ChapterContextUpdateArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChapterContexts.
     * @param {ChapterContextDeleteManyArgs} args - Arguments to filter ChapterContexts to delete.
     * @example
     * // Delete a few ChapterContexts
     * const { count } = await prisma.chapterContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterContextDeleteManyArgs>(args?: SelectSubset<T, ChapterContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterContexts
     * const chapterContext = await prisma.chapterContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterContextUpdateManyArgs>(args: SelectSubset<T, ChapterContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChapterContext.
     * @param {ChapterContextUpsertArgs} args - Arguments to update or create a ChapterContext.
     * @example
     * // Update or create a ChapterContext
     * const chapterContext = await prisma.chapterContext.upsert({
     *   create: {
     *     // ... data to create a ChapterContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterContext we want to update
     *   }
     * })
     */
    upsert<T extends ChapterContextUpsertArgs>(args: SelectSubset<T, ChapterContextUpsertArgs<ExtArgs>>): Prisma__ChapterContextClient<$Result.GetResult<Prisma.$ChapterContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChapterContexts that matches the filter.
     * @param {ChapterContextFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chapterContext = await prisma.chapterContext.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChapterContextFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ChapterContext.
     * @param {ChapterContextAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chapterContext = await prisma.chapterContext.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChapterContextAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ChapterContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextCountArgs} args - Arguments to filter ChapterContexts to count.
     * @example
     * // Count the number of ChapterContexts
     * const count = await prisma.chapterContext.count({
     *   where: {
     *     // ... the filter for the ChapterContexts we want to count
     *   }
     * })
    **/
    count<T extends ChapterContextCountArgs>(
      args?: Subset<T, ChapterContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterContextAggregateArgs>(args: Subset<T, ChapterContextAggregateArgs>): Prisma.PrismaPromise<GetChapterContextAggregateType<T>>

    /**
     * Group by ChapterContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterContextGroupByArgs['orderBy'] }
        : { orderBy?: ChapterContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterContext model
   */
  readonly fields: ChapterContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterContext model
   */
  interface ChapterContextFieldRefs {
    readonly id: FieldRef<"ChapterContext", 'String'>
    readonly title: FieldRef<"ChapterContext", 'String'>
    readonly author: FieldRef<"ChapterContext", 'String'>
    readonly authorSummary: FieldRef<"ChapterContext", 'String'>
    readonly content: FieldRef<"ChapterContext", 'String'>
    readonly meaning: FieldRef<"ChapterContext", 'String'>
    readonly summary: FieldRef<"ChapterContext", 'String'>
    readonly chapterId: FieldRef<"ChapterContext", 'String'>
    readonly createdAt: FieldRef<"ChapterContext", 'DateTime'>
    readonly updatedAt: FieldRef<"ChapterContext", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterContext findUnique
   */
  export type ChapterContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter, which ChapterContext to fetch.
     */
    where: ChapterContextWhereUniqueInput
  }

  /**
   * ChapterContext findUniqueOrThrow
   */
  export type ChapterContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter, which ChapterContext to fetch.
     */
    where: ChapterContextWhereUniqueInput
  }

  /**
   * ChapterContext findFirst
   */
  export type ChapterContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter, which ChapterContext to fetch.
     */
    where?: ChapterContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterContexts to fetch.
     */
    orderBy?: ChapterContextOrderByWithRelationInput | ChapterContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterContexts.
     */
    cursor?: ChapterContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterContexts.
     */
    distinct?: ChapterContextScalarFieldEnum | ChapterContextScalarFieldEnum[]
  }

  /**
   * ChapterContext findFirstOrThrow
   */
  export type ChapterContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter, which ChapterContext to fetch.
     */
    where?: ChapterContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterContexts to fetch.
     */
    orderBy?: ChapterContextOrderByWithRelationInput | ChapterContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterContexts.
     */
    cursor?: ChapterContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterContexts.
     */
    distinct?: ChapterContextScalarFieldEnum | ChapterContextScalarFieldEnum[]
  }

  /**
   * ChapterContext findMany
   */
  export type ChapterContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter, which ChapterContexts to fetch.
     */
    where?: ChapterContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterContexts to fetch.
     */
    orderBy?: ChapterContextOrderByWithRelationInput | ChapterContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterContexts.
     */
    cursor?: ChapterContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterContexts.
     */
    skip?: number
    distinct?: ChapterContextScalarFieldEnum | ChapterContextScalarFieldEnum[]
  }

  /**
   * ChapterContext create
   */
  export type ChapterContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterContext.
     */
    data: XOR<ChapterContextCreateInput, ChapterContextUncheckedCreateInput>
  }

  /**
   * ChapterContext createMany
   */
  export type ChapterContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterContexts.
     */
    data: ChapterContextCreateManyInput | ChapterContextCreateManyInput[]
  }

  /**
   * ChapterContext update
   */
  export type ChapterContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterContext.
     */
    data: XOR<ChapterContextUpdateInput, ChapterContextUncheckedUpdateInput>
    /**
     * Choose, which ChapterContext to update.
     */
    where: ChapterContextWhereUniqueInput
  }

  /**
   * ChapterContext updateMany
   */
  export type ChapterContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterContexts.
     */
    data: XOR<ChapterContextUpdateManyMutationInput, ChapterContextUncheckedUpdateManyInput>
    /**
     * Filter which ChapterContexts to update
     */
    where?: ChapterContextWhereInput
    /**
     * Limit how many ChapterContexts to update.
     */
    limit?: number
  }

  /**
   * ChapterContext upsert
   */
  export type ChapterContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterContext to update in case it exists.
     */
    where: ChapterContextWhereUniqueInput
    /**
     * In case the ChapterContext found by the `where` argument doesn't exist, create a new ChapterContext with this data.
     */
    create: XOR<ChapterContextCreateInput, ChapterContextUncheckedCreateInput>
    /**
     * In case the ChapterContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterContextUpdateInput, ChapterContextUncheckedUpdateInput>
  }

  /**
   * ChapterContext delete
   */
  export type ChapterContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
    /**
     * Filter which ChapterContext to delete.
     */
    where: ChapterContextWhereUniqueInput
  }

  /**
   * ChapterContext deleteMany
   */
  export type ChapterContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterContexts to delete
     */
    where?: ChapterContextWhereInput
    /**
     * Limit how many ChapterContexts to delete.
     */
    limit?: number
  }

  /**
   * ChapterContext findRaw
   */
  export type ChapterContextFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChapterContext aggregateRaw
   */
  export type ChapterContextAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChapterContext without action
   */
  export type ChapterContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterContext
     */
    select?: ChapterContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterContext
     */
    omit?: ChapterContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterContextInclude<ExtArgs> | null
  }


  /**
   * Model Mcq
   */

  export type AggregateMcq = {
    _count: McqCountAggregateOutputType | null
    _avg: McqAvgAggregateOutputType | null
    _sum: McqSumAggregateOutputType | null
    _min: McqMinAggregateOutputType | null
    _max: McqMaxAggregateOutputType | null
  }

  export type McqAvgAggregateOutputType = {
    session: number | null
  }

  export type McqSumAggregateOutputType = {
    session: number | null
  }

  export type McqMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    type: string | null
    reference: string | null
    explanation: string | null
    isMath: boolean | null
    session: number | null
    source: string | null
    questionUrl: string | null
    contextUrl: string | null
    context: string | null
    subjectId: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McqMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    type: string | null
    reference: string | null
    explanation: string | null
    isMath: boolean | null
    session: number | null
    source: string | null
    questionUrl: string | null
    contextUrl: string | null
    context: string | null
    subjectId: string | null
    chapterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McqCountAggregateOutputType = {
    id: number
    question: number
    options: number
    statements: number
    answer: number
    type: number
    reference: number
    explanation: number
    isMath: number
    session: number
    source: number
    questionUrl: number
    contextUrl: number
    context: number
    subjectId: number
    chapterId: number
    examIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type McqAvgAggregateInputType = {
    session?: true
  }

  export type McqSumAggregateInputType = {
    session?: true
  }

  export type McqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    type?: true
    reference?: true
    explanation?: true
    isMath?: true
    session?: true
    source?: true
    questionUrl?: true
    contextUrl?: true
    context?: true
    subjectId?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    type?: true
    reference?: true
    explanation?: true
    isMath?: true
    session?: true
    source?: true
    questionUrl?: true
    contextUrl?: true
    context?: true
    subjectId?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McqCountAggregateInputType = {
    id?: true
    question?: true
    options?: true
    statements?: true
    answer?: true
    type?: true
    reference?: true
    explanation?: true
    isMath?: true
    session?: true
    source?: true
    questionUrl?: true
    contextUrl?: true
    context?: true
    subjectId?: true
    chapterId?: true
    examIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type McqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mcq to aggregate.
     */
    where?: McqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mcqs to fetch.
     */
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: McqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mcqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mcqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mcqs
    **/
    _count?: true | McqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: McqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: McqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: McqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: McqMaxAggregateInputType
  }

  export type GetMcqAggregateType<T extends McqAggregateArgs> = {
        [P in keyof T & keyof AggregateMcq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMcq[P]>
      : GetScalarType<T[P], AggregateMcq[P]>
  }




  export type McqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqWhereInput
    orderBy?: McqOrderByWithAggregationInput | McqOrderByWithAggregationInput[]
    by: McqScalarFieldEnum[] | McqScalarFieldEnum
    having?: McqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: McqCountAggregateInputType | true
    _avg?: McqAvgAggregateInputType
    _sum?: McqSumAggregateInputType
    _min?: McqMinAggregateInputType
    _max?: McqMaxAggregateInputType
  }

  export type McqGroupByOutputType = {
    id: string
    question: string
    options: string[]
    statements: string[]
    answer: string
    type: string
    reference: string | null
    explanation: string | null
    isMath: boolean
    session: number
    source: string | null
    questionUrl: string | null
    contextUrl: string | null
    context: string | null
    subjectId: string
    chapterId: string
    examIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: McqCountAggregateOutputType | null
    _avg: McqAvgAggregateOutputType | null
    _sum: McqSumAggregateOutputType | null
    _min: McqMinAggregateOutputType | null
    _max: McqMaxAggregateOutputType | null
  }

  type GetMcqGroupByPayload<T extends McqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<McqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof McqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], McqGroupByOutputType[P]>
            : GetScalarType<T[P], McqGroupByOutputType[P]>
        }
      >
    >


  export type McqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    options?: boolean
    statements?: boolean
    answer?: boolean
    type?: boolean
    reference?: boolean
    explanation?: boolean
    isMath?: boolean
    session?: boolean
    source?: boolean
    questionUrl?: boolean
    contextUrl?: boolean
    context?: boolean
    subjectId?: boolean
    chapterId?: boolean
    examIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    exams?: boolean | Mcq$examsArgs<ExtArgs>
    _count?: boolean | McqCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mcq"]>



  export type McqSelectScalar = {
    id?: boolean
    question?: boolean
    options?: boolean
    statements?: boolean
    answer?: boolean
    type?: boolean
    reference?: boolean
    explanation?: boolean
    isMath?: boolean
    session?: boolean
    source?: boolean
    questionUrl?: boolean
    contextUrl?: boolean
    context?: boolean
    subjectId?: boolean
    chapterId?: boolean
    examIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type McqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "options" | "statements" | "answer" | "type" | "reference" | "explanation" | "isMath" | "session" | "source" | "questionUrl" | "contextUrl" | "context" | "subjectId" | "chapterId" | "examIds" | "createdAt" | "updatedAt", ExtArgs["result"]["mcq"]>
  export type McqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    exams?: boolean | Mcq$examsArgs<ExtArgs>
    _count?: boolean | McqCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $McqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mcq"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
      exams: Prisma.$ExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      options: string[]
      statements: string[]
      answer: string
      type: string
      reference: string | null
      explanation: string | null
      isMath: boolean
      session: number
      source: string | null
      questionUrl: string | null
      contextUrl: string | null
      context: string | null
      subjectId: string
      chapterId: string
      examIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mcq"]>
    composites: {}
  }

  type McqGetPayload<S extends boolean | null | undefined | McqDefaultArgs> = $Result.GetResult<Prisma.$McqPayload, S>

  type McqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<McqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: McqCountAggregateInputType | true
    }

  export interface McqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mcq'], meta: { name: 'Mcq' } }
    /**
     * Find zero or one Mcq that matches the filter.
     * @param {McqFindUniqueArgs} args - Arguments to find a Mcq
     * @example
     * // Get one Mcq
     * const mcq = await prisma.mcq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends McqFindUniqueArgs>(args: SelectSubset<T, McqFindUniqueArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mcq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {McqFindUniqueOrThrowArgs} args - Arguments to find a Mcq
     * @example
     * // Get one Mcq
     * const mcq = await prisma.mcq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends McqFindUniqueOrThrowArgs>(args: SelectSubset<T, McqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mcq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqFindFirstArgs} args - Arguments to find a Mcq
     * @example
     * // Get one Mcq
     * const mcq = await prisma.mcq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends McqFindFirstArgs>(args?: SelectSubset<T, McqFindFirstArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mcq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqFindFirstOrThrowArgs} args - Arguments to find a Mcq
     * @example
     * // Get one Mcq
     * const mcq = await prisma.mcq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends McqFindFirstOrThrowArgs>(args?: SelectSubset<T, McqFindFirstOrThrowArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mcqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mcqs
     * const mcqs = await prisma.mcq.findMany()
     * 
     * // Get first 10 Mcqs
     * const mcqs = await prisma.mcq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mcqWithIdOnly = await prisma.mcq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends McqFindManyArgs>(args?: SelectSubset<T, McqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mcq.
     * @param {McqCreateArgs} args - Arguments to create a Mcq.
     * @example
     * // Create one Mcq
     * const Mcq = await prisma.mcq.create({
     *   data: {
     *     // ... data to create a Mcq
     *   }
     * })
     * 
     */
    create<T extends McqCreateArgs>(args: SelectSubset<T, McqCreateArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mcqs.
     * @param {McqCreateManyArgs} args - Arguments to create many Mcqs.
     * @example
     * // Create many Mcqs
     * const mcq = await prisma.mcq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends McqCreateManyArgs>(args?: SelectSubset<T, McqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mcq.
     * @param {McqDeleteArgs} args - Arguments to delete one Mcq.
     * @example
     * // Delete one Mcq
     * const Mcq = await prisma.mcq.delete({
     *   where: {
     *     // ... filter to delete one Mcq
     *   }
     * })
     * 
     */
    delete<T extends McqDeleteArgs>(args: SelectSubset<T, McqDeleteArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mcq.
     * @param {McqUpdateArgs} args - Arguments to update one Mcq.
     * @example
     * // Update one Mcq
     * const mcq = await prisma.mcq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends McqUpdateArgs>(args: SelectSubset<T, McqUpdateArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mcqs.
     * @param {McqDeleteManyArgs} args - Arguments to filter Mcqs to delete.
     * @example
     * // Delete a few Mcqs
     * const { count } = await prisma.mcq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends McqDeleteManyArgs>(args?: SelectSubset<T, McqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mcqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mcqs
     * const mcq = await prisma.mcq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends McqUpdateManyArgs>(args: SelectSubset<T, McqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mcq.
     * @param {McqUpsertArgs} args - Arguments to update or create a Mcq.
     * @example
     * // Update or create a Mcq
     * const mcq = await prisma.mcq.upsert({
     *   create: {
     *     // ... data to create a Mcq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mcq we want to update
     *   }
     * })
     */
    upsert<T extends McqUpsertArgs>(args: SelectSubset<T, McqUpsertArgs<ExtArgs>>): Prisma__McqClient<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mcqs that matches the filter.
     * @param {McqFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mcq = await prisma.mcq.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: McqFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Mcq.
     * @param {McqAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mcq = await prisma.mcq.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: McqAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Mcqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqCountArgs} args - Arguments to filter Mcqs to count.
     * @example
     * // Count the number of Mcqs
     * const count = await prisma.mcq.count({
     *   where: {
     *     // ... the filter for the Mcqs we want to count
     *   }
     * })
    **/
    count<T extends McqCountArgs>(
      args?: Subset<T, McqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], McqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mcq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends McqAggregateArgs>(args: Subset<T, McqAggregateArgs>): Prisma.PrismaPromise<GetMcqAggregateType<T>>

    /**
     * Group by Mcq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends McqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: McqGroupByArgs['orderBy'] }
        : { orderBy?: McqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, McqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMcqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mcq model
   */
  readonly fields: McqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mcq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__McqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exams<T extends Mcq$examsArgs<ExtArgs> = {}>(args?: Subset<T, Mcq$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mcq model
   */
  interface McqFieldRefs {
    readonly id: FieldRef<"Mcq", 'String'>
    readonly question: FieldRef<"Mcq", 'String'>
    readonly options: FieldRef<"Mcq", 'String[]'>
    readonly statements: FieldRef<"Mcq", 'String[]'>
    readonly answer: FieldRef<"Mcq", 'String'>
    readonly type: FieldRef<"Mcq", 'String'>
    readonly reference: FieldRef<"Mcq", 'String'>
    readonly explanation: FieldRef<"Mcq", 'String'>
    readonly isMath: FieldRef<"Mcq", 'Boolean'>
    readonly session: FieldRef<"Mcq", 'Int'>
    readonly source: FieldRef<"Mcq", 'String'>
    readonly questionUrl: FieldRef<"Mcq", 'String'>
    readonly contextUrl: FieldRef<"Mcq", 'String'>
    readonly context: FieldRef<"Mcq", 'String'>
    readonly subjectId: FieldRef<"Mcq", 'String'>
    readonly chapterId: FieldRef<"Mcq", 'String'>
    readonly examIds: FieldRef<"Mcq", 'String[]'>
    readonly createdAt: FieldRef<"Mcq", 'DateTime'>
    readonly updatedAt: FieldRef<"Mcq", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mcq findUnique
   */
  export type McqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter, which Mcq to fetch.
     */
    where: McqWhereUniqueInput
  }

  /**
   * Mcq findUniqueOrThrow
   */
  export type McqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter, which Mcq to fetch.
     */
    where: McqWhereUniqueInput
  }

  /**
   * Mcq findFirst
   */
  export type McqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter, which Mcq to fetch.
     */
    where?: McqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mcqs to fetch.
     */
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mcqs.
     */
    cursor?: McqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mcqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mcqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mcqs.
     */
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Mcq findFirstOrThrow
   */
  export type McqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter, which Mcq to fetch.
     */
    where?: McqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mcqs to fetch.
     */
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mcqs.
     */
    cursor?: McqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mcqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mcqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mcqs.
     */
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Mcq findMany
   */
  export type McqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter, which Mcqs to fetch.
     */
    where?: McqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mcqs to fetch.
     */
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mcqs.
     */
    cursor?: McqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mcqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mcqs.
     */
    skip?: number
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Mcq create
   */
  export type McqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * The data needed to create a Mcq.
     */
    data: XOR<McqCreateInput, McqUncheckedCreateInput>
  }

  /**
   * Mcq createMany
   */
  export type McqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mcqs.
     */
    data: McqCreateManyInput | McqCreateManyInput[]
  }

  /**
   * Mcq update
   */
  export type McqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * The data needed to update a Mcq.
     */
    data: XOR<McqUpdateInput, McqUncheckedUpdateInput>
    /**
     * Choose, which Mcq to update.
     */
    where: McqWhereUniqueInput
  }

  /**
   * Mcq updateMany
   */
  export type McqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mcqs.
     */
    data: XOR<McqUpdateManyMutationInput, McqUncheckedUpdateManyInput>
    /**
     * Filter which Mcqs to update
     */
    where?: McqWhereInput
    /**
     * Limit how many Mcqs to update.
     */
    limit?: number
  }

  /**
   * Mcq upsert
   */
  export type McqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * The filter to search for the Mcq to update in case it exists.
     */
    where: McqWhereUniqueInput
    /**
     * In case the Mcq found by the `where` argument doesn't exist, create a new Mcq with this data.
     */
    create: XOR<McqCreateInput, McqUncheckedCreateInput>
    /**
     * In case the Mcq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<McqUpdateInput, McqUncheckedUpdateInput>
  }

  /**
   * Mcq delete
   */
  export type McqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    /**
     * Filter which Mcq to delete.
     */
    where: McqWhereUniqueInput
  }

  /**
   * Mcq deleteMany
   */
  export type McqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mcqs to delete
     */
    where?: McqWhereInput
    /**
     * Limit how many Mcqs to delete.
     */
    limit?: number
  }

  /**
   * Mcq findRaw
   */
  export type McqFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mcq aggregateRaw
   */
  export type McqAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Mcq.exams
   */
  export type Mcq$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Mcq without action
   */
  export type McqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    questionCount: number | null
    duration: number | null
  }

  export type ExamSumAggregateOutputType = {
    questionCount: number | null
    duration: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    questionCount: number | null
    duration: number | null
    status: string | null
    classNameId: string | null
    subjectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    type: string | null
    questionCount: number | null
    duration: number | null
    status: string | null
    classNameId: string | null
    subjectId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    type: number
    questionCount: number
    duration: number
    status: number
    classNameId: number
    subjectId: number
    chapterIds: number
    questionIds: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    questionCount?: true
    duration?: true
  }

  export type ExamSumAggregateInputType = {
    questionCount?: true
    duration?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    questionCount?: true
    duration?: true
    status?: true
    classNameId?: true
    subjectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    questionCount?: true
    duration?: true
    status?: true
    classNameId?: true
    subjectId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    questionCount?: true
    duration?: true
    status?: true
    classNameId?: true
    subjectId?: true
    chapterIds?: true
    questionIds?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    type: string
    questionCount: number
    duration: number
    status: string
    classNameId: string
    subjectId: string
    chapterIds: string[]
    questionIds: string[]
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    questionCount?: boolean
    duration?: boolean
    status?: boolean
    classNameId?: boolean
    subjectId?: boolean
    chapterIds?: boolean
    questionIds?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    className?: boolean | ClassNameDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapters?: boolean | Exam$chaptersArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    recommendations?: boolean | Exam$recommendationsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>



  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    questionCount?: boolean
    duration?: boolean
    status?: boolean
    classNameId?: boolean
    subjectId?: boolean
    chapterIds?: boolean
    questionIds?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "questionCount" | "duration" | "status" | "classNameId" | "subjectId" | "chapterIds" | "questionIds" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    className?: boolean | ClassNameDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    chapters?: boolean | Exam$chaptersArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    recommendations?: boolean | Exam$recommendationsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      className: Prisma.$ClassNamePayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      questions: Prisma.$McqPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      attempts: Prisma.$McqAttemptPayload<ExtArgs>[]
      recommendations: Prisma.$RecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      type: string
      questionCount: number
      duration: number
      status: string
      classNameId: string
      subjectId: string
      chapterIds: string[]
      questionIds: string[]
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * @param {ExamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const exam = await prisma.exam.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Exam.
     * @param {ExamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const exam = await prisma.exam.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    className<T extends ClassNameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassNameDefaultArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Exam$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Exam$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Exam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attempts<T extends Exam$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recommendations<T extends Exam$recommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$recommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly type: FieldRef<"Exam", 'String'>
    readonly questionCount: FieldRef<"Exam", 'Int'>
    readonly duration: FieldRef<"Exam", 'Int'>
    readonly status: FieldRef<"Exam", 'String'>
    readonly classNameId: FieldRef<"Exam", 'String'>
    readonly subjectId: FieldRef<"Exam", 'String'>
    readonly chapterIds: FieldRef<"Exam", 'String[]'>
    readonly questionIds: FieldRef<"Exam", 'String[]'>
    readonly userId: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam findRaw
   */
  export type ExamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exam aggregateRaw
   */
  export type ExamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exam.chapters
   */
  export type Exam$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Exam.questions
   */
  export type Exam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mcq
     */
    select?: McqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mcq
     */
    omit?: McqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqInclude<ExtArgs> | null
    where?: McqWhereInput
    orderBy?: McqOrderByWithRelationInput | McqOrderByWithRelationInput[]
    cursor?: McqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: McqScalarFieldEnum | McqScalarFieldEnum[]
  }

  /**
   * Exam.attempts
   */
  export type Exam$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    where?: McqAttemptWhereInput
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    cursor?: McqAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: McqAttemptScalarFieldEnum | McqAttemptScalarFieldEnum[]
  }

  /**
   * Exam.recommendations
   */
  export type Exam$recommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    cursor?: RecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model McqAttempt
   */

  export type AggregateMcqAttempt = {
    _count: McqAttemptCountAggregateOutputType | null
    _avg: McqAttemptAvgAggregateOutputType | null
    _sum: McqAttemptSumAggregateOutputType | null
    _min: McqAttemptMinAggregateOutputType | null
    _max: McqAttemptMaxAggregateOutputType | null
  }

  export type McqAttemptAvgAggregateOutputType = {
    total: number | null
    score: number | null
    streak: number | null
    longestStreak: number | null
    wrongAnswer: number | null
  }

  export type McqAttemptSumAggregateOutputType = {
    total: number | null
    score: number | null
    streak: number | null
    longestStreak: number | null
    wrongAnswer: number | null
  }

  export type McqAttemptMinAggregateOutputType = {
    id: string | null
    total: number | null
    score: number | null
    streak: number | null
    longestStreak: number | null
    wrongAnswer: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    examId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McqAttemptMaxAggregateOutputType = {
    id: string | null
    total: number | null
    score: number | null
    streak: number | null
    longestStreak: number | null
    wrongAnswer: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    examId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type McqAttemptCountAggregateOutputType = {
    id: number
    answers: number
    total: number
    score: number
    streak: number
    longestStreak: number
    wrongAnswer: number
    status: number
    startTime: number
    endTime: number
    examId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type McqAttemptAvgAggregateInputType = {
    total?: true
    score?: true
    streak?: true
    longestStreak?: true
    wrongAnswer?: true
  }

  export type McqAttemptSumAggregateInputType = {
    total?: true
    score?: true
    streak?: true
    longestStreak?: true
    wrongAnswer?: true
  }

  export type McqAttemptMinAggregateInputType = {
    id?: true
    total?: true
    score?: true
    streak?: true
    longestStreak?: true
    wrongAnswer?: true
    status?: true
    startTime?: true
    endTime?: true
    examId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McqAttemptMaxAggregateInputType = {
    id?: true
    total?: true
    score?: true
    streak?: true
    longestStreak?: true
    wrongAnswer?: true
    status?: true
    startTime?: true
    endTime?: true
    examId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type McqAttemptCountAggregateInputType = {
    id?: true
    answers?: true
    total?: true
    score?: true
    streak?: true
    longestStreak?: true
    wrongAnswer?: true
    status?: true
    startTime?: true
    endTime?: true
    examId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type McqAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McqAttempt to aggregate.
     */
    where?: McqAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqAttempts to fetch.
     */
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: McqAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned McqAttempts
    **/
    _count?: true | McqAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: McqAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: McqAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: McqAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: McqAttemptMaxAggregateInputType
  }

  export type GetMcqAttemptAggregateType<T extends McqAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateMcqAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMcqAttempt[P]>
      : GetScalarType<T[P], AggregateMcqAttempt[P]>
  }




  export type McqAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: McqAttemptWhereInput
    orderBy?: McqAttemptOrderByWithAggregationInput | McqAttemptOrderByWithAggregationInput[]
    by: McqAttemptScalarFieldEnum[] | McqAttemptScalarFieldEnum
    having?: McqAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: McqAttemptCountAggregateInputType | true
    _avg?: McqAttemptAvgAggregateInputType
    _sum?: McqAttemptSumAggregateInputType
    _min?: McqAttemptMinAggregateInputType
    _max?: McqAttemptMaxAggregateInputType
  }

  export type McqAttemptGroupByOutputType = {
    id: string
    answers: string[]
    total: number
    score: number
    streak: number
    longestStreak: number
    wrongAnswer: number
    status: string
    startTime: Date | null
    endTime: Date | null
    examId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: McqAttemptCountAggregateOutputType | null
    _avg: McqAttemptAvgAggregateOutputType | null
    _sum: McqAttemptSumAggregateOutputType | null
    _min: McqAttemptMinAggregateOutputType | null
    _max: McqAttemptMaxAggregateOutputType | null
  }

  type GetMcqAttemptGroupByPayload<T extends McqAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<McqAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof McqAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], McqAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], McqAttemptGroupByOutputType[P]>
        }
      >
    >


  export type McqAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answers?: boolean
    total?: boolean
    score?: boolean
    streak?: boolean
    longestStreak?: boolean
    wrongAnswer?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    examId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    feedback?: boolean | McqAttempt$feedbackArgs<ExtArgs>
  }, ExtArgs["result"]["mcqAttempt"]>



  export type McqAttemptSelectScalar = {
    id?: boolean
    answers?: boolean
    total?: boolean
    score?: boolean
    streak?: boolean
    longestStreak?: boolean
    wrongAnswer?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    examId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type McqAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "answers" | "total" | "score" | "streak" | "longestStreak" | "wrongAnswer" | "status" | "startTime" | "endTime" | "examId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["mcqAttempt"]>
  export type McqAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    feedback?: boolean | McqAttempt$feedbackArgs<ExtArgs>
  }

  export type $McqAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "McqAttempt"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      feedback: Prisma.$ExamFeedbackPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      answers: string[]
      total: number
      score: number
      streak: number
      longestStreak: number
      wrongAnswer: number
      status: string
      startTime: Date | null
      endTime: Date | null
      examId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mcqAttempt"]>
    composites: {}
  }

  type McqAttemptGetPayload<S extends boolean | null | undefined | McqAttemptDefaultArgs> = $Result.GetResult<Prisma.$McqAttemptPayload, S>

  type McqAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<McqAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: McqAttemptCountAggregateInputType | true
    }

  export interface McqAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['McqAttempt'], meta: { name: 'McqAttempt' } }
    /**
     * Find zero or one McqAttempt that matches the filter.
     * @param {McqAttemptFindUniqueArgs} args - Arguments to find a McqAttempt
     * @example
     * // Get one McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends McqAttemptFindUniqueArgs>(args: SelectSubset<T, McqAttemptFindUniqueArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one McqAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {McqAttemptFindUniqueOrThrowArgs} args - Arguments to find a McqAttempt
     * @example
     * // Get one McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends McqAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, McqAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first McqAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptFindFirstArgs} args - Arguments to find a McqAttempt
     * @example
     * // Get one McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends McqAttemptFindFirstArgs>(args?: SelectSubset<T, McqAttemptFindFirstArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first McqAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptFindFirstOrThrowArgs} args - Arguments to find a McqAttempt
     * @example
     * // Get one McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends McqAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, McqAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more McqAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all McqAttempts
     * const mcqAttempts = await prisma.mcqAttempt.findMany()
     * 
     * // Get first 10 McqAttempts
     * const mcqAttempts = await prisma.mcqAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mcqAttemptWithIdOnly = await prisma.mcqAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends McqAttemptFindManyArgs>(args?: SelectSubset<T, McqAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a McqAttempt.
     * @param {McqAttemptCreateArgs} args - Arguments to create a McqAttempt.
     * @example
     * // Create one McqAttempt
     * const McqAttempt = await prisma.mcqAttempt.create({
     *   data: {
     *     // ... data to create a McqAttempt
     *   }
     * })
     * 
     */
    create<T extends McqAttemptCreateArgs>(args: SelectSubset<T, McqAttemptCreateArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many McqAttempts.
     * @param {McqAttemptCreateManyArgs} args - Arguments to create many McqAttempts.
     * @example
     * // Create many McqAttempts
     * const mcqAttempt = await prisma.mcqAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends McqAttemptCreateManyArgs>(args?: SelectSubset<T, McqAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a McqAttempt.
     * @param {McqAttemptDeleteArgs} args - Arguments to delete one McqAttempt.
     * @example
     * // Delete one McqAttempt
     * const McqAttempt = await prisma.mcqAttempt.delete({
     *   where: {
     *     // ... filter to delete one McqAttempt
     *   }
     * })
     * 
     */
    delete<T extends McqAttemptDeleteArgs>(args: SelectSubset<T, McqAttemptDeleteArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one McqAttempt.
     * @param {McqAttemptUpdateArgs} args - Arguments to update one McqAttempt.
     * @example
     * // Update one McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends McqAttemptUpdateArgs>(args: SelectSubset<T, McqAttemptUpdateArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more McqAttempts.
     * @param {McqAttemptDeleteManyArgs} args - Arguments to filter McqAttempts to delete.
     * @example
     * // Delete a few McqAttempts
     * const { count } = await prisma.mcqAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends McqAttemptDeleteManyArgs>(args?: SelectSubset<T, McqAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more McqAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many McqAttempts
     * const mcqAttempt = await prisma.mcqAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends McqAttemptUpdateManyArgs>(args: SelectSubset<T, McqAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one McqAttempt.
     * @param {McqAttemptUpsertArgs} args - Arguments to update or create a McqAttempt.
     * @example
     * // Update or create a McqAttempt
     * const mcqAttempt = await prisma.mcqAttempt.upsert({
     *   create: {
     *     // ... data to create a McqAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the McqAttempt we want to update
     *   }
     * })
     */
    upsert<T extends McqAttemptUpsertArgs>(args: SelectSubset<T, McqAttemptUpsertArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more McqAttempts that matches the filter.
     * @param {McqAttemptFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mcqAttempt = await prisma.mcqAttempt.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: McqAttemptFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a McqAttempt.
     * @param {McqAttemptAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mcqAttempt = await prisma.mcqAttempt.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: McqAttemptAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of McqAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptCountArgs} args - Arguments to filter McqAttempts to count.
     * @example
     * // Count the number of McqAttempts
     * const count = await prisma.mcqAttempt.count({
     *   where: {
     *     // ... the filter for the McqAttempts we want to count
     *   }
     * })
    **/
    count<T extends McqAttemptCountArgs>(
      args?: Subset<T, McqAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], McqAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a McqAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends McqAttemptAggregateArgs>(args: Subset<T, McqAttemptAggregateArgs>): Prisma.PrismaPromise<GetMcqAttemptAggregateType<T>>

    /**
     * Group by McqAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {McqAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends McqAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: McqAttemptGroupByArgs['orderBy'] }
        : { orderBy?: McqAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, McqAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMcqAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the McqAttempt model
   */
  readonly fields: McqAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for McqAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__McqAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feedback<T extends McqAttempt$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, McqAttempt$feedbackArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the McqAttempt model
   */
  interface McqAttemptFieldRefs {
    readonly id: FieldRef<"McqAttempt", 'String'>
    readonly answers: FieldRef<"McqAttempt", 'String[]'>
    readonly total: FieldRef<"McqAttempt", 'Int'>
    readonly score: FieldRef<"McqAttempt", 'Int'>
    readonly streak: FieldRef<"McqAttempt", 'Int'>
    readonly longestStreak: FieldRef<"McqAttempt", 'Int'>
    readonly wrongAnswer: FieldRef<"McqAttempt", 'Int'>
    readonly status: FieldRef<"McqAttempt", 'String'>
    readonly startTime: FieldRef<"McqAttempt", 'DateTime'>
    readonly endTime: FieldRef<"McqAttempt", 'DateTime'>
    readonly examId: FieldRef<"McqAttempt", 'String'>
    readonly userId: FieldRef<"McqAttempt", 'String'>
    readonly createdAt: FieldRef<"McqAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"McqAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * McqAttempt findUnique
   */
  export type McqAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter, which McqAttempt to fetch.
     */
    where: McqAttemptWhereUniqueInput
  }

  /**
   * McqAttempt findUniqueOrThrow
   */
  export type McqAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter, which McqAttempt to fetch.
     */
    where: McqAttemptWhereUniqueInput
  }

  /**
   * McqAttempt findFirst
   */
  export type McqAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter, which McqAttempt to fetch.
     */
    where?: McqAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqAttempts to fetch.
     */
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McqAttempts.
     */
    cursor?: McqAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McqAttempts.
     */
    distinct?: McqAttemptScalarFieldEnum | McqAttemptScalarFieldEnum[]
  }

  /**
   * McqAttempt findFirstOrThrow
   */
  export type McqAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter, which McqAttempt to fetch.
     */
    where?: McqAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqAttempts to fetch.
     */
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for McqAttempts.
     */
    cursor?: McqAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of McqAttempts.
     */
    distinct?: McqAttemptScalarFieldEnum | McqAttemptScalarFieldEnum[]
  }

  /**
   * McqAttempt findMany
   */
  export type McqAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter, which McqAttempts to fetch.
     */
    where?: McqAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of McqAttempts to fetch.
     */
    orderBy?: McqAttemptOrderByWithRelationInput | McqAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing McqAttempts.
     */
    cursor?: McqAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` McqAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` McqAttempts.
     */
    skip?: number
    distinct?: McqAttemptScalarFieldEnum | McqAttemptScalarFieldEnum[]
  }

  /**
   * McqAttempt create
   */
  export type McqAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a McqAttempt.
     */
    data: XOR<McqAttemptCreateInput, McqAttemptUncheckedCreateInput>
  }

  /**
   * McqAttempt createMany
   */
  export type McqAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many McqAttempts.
     */
    data: McqAttemptCreateManyInput | McqAttemptCreateManyInput[]
  }

  /**
   * McqAttempt update
   */
  export type McqAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a McqAttempt.
     */
    data: XOR<McqAttemptUpdateInput, McqAttemptUncheckedUpdateInput>
    /**
     * Choose, which McqAttempt to update.
     */
    where: McqAttemptWhereUniqueInput
  }

  /**
   * McqAttempt updateMany
   */
  export type McqAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update McqAttempts.
     */
    data: XOR<McqAttemptUpdateManyMutationInput, McqAttemptUncheckedUpdateManyInput>
    /**
     * Filter which McqAttempts to update
     */
    where?: McqAttemptWhereInput
    /**
     * Limit how many McqAttempts to update.
     */
    limit?: number
  }

  /**
   * McqAttempt upsert
   */
  export type McqAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the McqAttempt to update in case it exists.
     */
    where: McqAttemptWhereUniqueInput
    /**
     * In case the McqAttempt found by the `where` argument doesn't exist, create a new McqAttempt with this data.
     */
    create: XOR<McqAttemptCreateInput, McqAttemptUncheckedCreateInput>
    /**
     * In case the McqAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<McqAttemptUpdateInput, McqAttemptUncheckedUpdateInput>
  }

  /**
   * McqAttempt delete
   */
  export type McqAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
    /**
     * Filter which McqAttempt to delete.
     */
    where: McqAttemptWhereUniqueInput
  }

  /**
   * McqAttempt deleteMany
   */
  export type McqAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which McqAttempts to delete
     */
    where?: McqAttemptWhereInput
    /**
     * Limit how many McqAttempts to delete.
     */
    limit?: number
  }

  /**
   * McqAttempt findRaw
   */
  export type McqAttemptFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * McqAttempt aggregateRaw
   */
  export type McqAttemptAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * McqAttempt.feedback
   */
  export type McqAttempt$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    where?: ExamFeedbackWhereInput
  }

  /**
   * McqAttempt without action
   */
  export type McqAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the McqAttempt
     */
    select?: McqAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the McqAttempt
     */
    omit?: McqAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: McqAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ExamFeedback
   */

  export type AggregateExamFeedback = {
    _count: ExamFeedbackCountAggregateOutputType | null
    _avg: ExamFeedbackAvgAggregateOutputType | null
    _sum: ExamFeedbackSumAggregateOutputType | null
    _min: ExamFeedbackMinAggregateOutputType | null
    _max: ExamFeedbackMaxAggregateOutputType | null
  }

  export type ExamFeedbackAvgAggregateOutputType = {
    userRating: number | null
  }

  export type ExamFeedbackSumAggregateOutputType = {
    userRating: number | null
  }

  export type ExamFeedbackMinAggregateOutputType = {
    id: string | null
    mcqAttemptId: string | null
    userId: string | null
    overallSummary: string | null
    userRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamFeedbackMaxAggregateOutputType = {
    id: string | null
    mcqAttemptId: string | null
    userId: string | null
    overallSummary: string | null
    userRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamFeedbackCountAggregateOutputType = {
    id: number
    mcqAttemptId: number
    userId: number
    overallSummary: number
    strengths: number
    weaknesses: number
    recommendations: number
    detailedAnalysis: number
    userRating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamFeedbackAvgAggregateInputType = {
    userRating?: true
  }

  export type ExamFeedbackSumAggregateInputType = {
    userRating?: true
  }

  export type ExamFeedbackMinAggregateInputType = {
    id?: true
    mcqAttemptId?: true
    userId?: true
    overallSummary?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamFeedbackMaxAggregateInputType = {
    id?: true
    mcqAttemptId?: true
    userId?: true
    overallSummary?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamFeedbackCountAggregateInputType = {
    id?: true
    mcqAttemptId?: true
    userId?: true
    overallSummary?: true
    strengths?: true
    weaknesses?: true
    recommendations?: true
    detailedAnalysis?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamFeedback to aggregate.
     */
    where?: ExamFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamFeedbacks to fetch.
     */
    orderBy?: ExamFeedbackOrderByWithRelationInput | ExamFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamFeedbacks
    **/
    _count?: true | ExamFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamFeedbackMaxAggregateInputType
  }

  export type GetExamFeedbackAggregateType<T extends ExamFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateExamFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamFeedback[P]>
      : GetScalarType<T[P], AggregateExamFeedback[P]>
  }




  export type ExamFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamFeedbackWhereInput
    orderBy?: ExamFeedbackOrderByWithAggregationInput | ExamFeedbackOrderByWithAggregationInput[]
    by: ExamFeedbackScalarFieldEnum[] | ExamFeedbackScalarFieldEnum
    having?: ExamFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamFeedbackCountAggregateInputType | true
    _avg?: ExamFeedbackAvgAggregateInputType
    _sum?: ExamFeedbackSumAggregateInputType
    _min?: ExamFeedbackMinAggregateInputType
    _max?: ExamFeedbackMaxAggregateInputType
  }

  export type ExamFeedbackGroupByOutputType = {
    id: string
    mcqAttemptId: string
    userId: string
    overallSummary: string
    strengths: string[]
    weaknesses: string[]
    recommendations: string[]
    detailedAnalysis: JsonValue | null
    userRating: number | null
    createdAt: Date
    updatedAt: Date
    _count: ExamFeedbackCountAggregateOutputType | null
    _avg: ExamFeedbackAvgAggregateOutputType | null
    _sum: ExamFeedbackSumAggregateOutputType | null
    _min: ExamFeedbackMinAggregateOutputType | null
    _max: ExamFeedbackMaxAggregateOutputType | null
  }

  type GetExamFeedbackGroupByPayload<T extends ExamFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], ExamFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type ExamFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mcqAttemptId?: boolean
    userId?: boolean
    overallSummary?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    detailedAnalysis?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mcqAttempt?: boolean | McqAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examFeedback"]>



  export type ExamFeedbackSelectScalar = {
    id?: boolean
    mcqAttemptId?: boolean
    userId?: boolean
    overallSummary?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    detailedAnalysis?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mcqAttemptId" | "userId" | "overallSummary" | "strengths" | "weaknesses" | "recommendations" | "detailedAnalysis" | "userRating" | "createdAt" | "updatedAt", ExtArgs["result"]["examFeedback"]>
  export type ExamFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcqAttempt?: boolean | McqAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExamFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamFeedback"
    objects: {
      mcqAttempt: Prisma.$McqAttemptPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mcqAttemptId: string
      userId: string
      overallSummary: string
      strengths: string[]
      weaknesses: string[]
      recommendations: string[]
      detailedAnalysis: Prisma.JsonValue | null
      userRating: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examFeedback"]>
    composites: {}
  }

  type ExamFeedbackGetPayload<S extends boolean | null | undefined | ExamFeedbackDefaultArgs> = $Result.GetResult<Prisma.$ExamFeedbackPayload, S>

  type ExamFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamFeedbackCountAggregateInputType | true
    }

  export interface ExamFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamFeedback'], meta: { name: 'ExamFeedback' } }
    /**
     * Find zero or one ExamFeedback that matches the filter.
     * @param {ExamFeedbackFindUniqueArgs} args - Arguments to find a ExamFeedback
     * @example
     * // Get one ExamFeedback
     * const examFeedback = await prisma.examFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFeedbackFindUniqueArgs>(args: SelectSubset<T, ExamFeedbackFindUniqueArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFeedbackFindUniqueOrThrowArgs} args - Arguments to find a ExamFeedback
     * @example
     * // Get one ExamFeedback
     * const examFeedback = await prisma.examFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackFindFirstArgs} args - Arguments to find a ExamFeedback
     * @example
     * // Get one ExamFeedback
     * const examFeedback = await prisma.examFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFeedbackFindFirstArgs>(args?: SelectSubset<T, ExamFeedbackFindFirstArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackFindFirstOrThrowArgs} args - Arguments to find a ExamFeedback
     * @example
     * // Get one ExamFeedback
     * const examFeedback = await prisma.examFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamFeedbacks
     * const examFeedbacks = await prisma.examFeedback.findMany()
     * 
     * // Get first 10 ExamFeedbacks
     * const examFeedbacks = await prisma.examFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examFeedbackWithIdOnly = await prisma.examFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFeedbackFindManyArgs>(args?: SelectSubset<T, ExamFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamFeedback.
     * @param {ExamFeedbackCreateArgs} args - Arguments to create a ExamFeedback.
     * @example
     * // Create one ExamFeedback
     * const ExamFeedback = await prisma.examFeedback.create({
     *   data: {
     *     // ... data to create a ExamFeedback
     *   }
     * })
     * 
     */
    create<T extends ExamFeedbackCreateArgs>(args: SelectSubset<T, ExamFeedbackCreateArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamFeedbacks.
     * @param {ExamFeedbackCreateManyArgs} args - Arguments to create many ExamFeedbacks.
     * @example
     * // Create many ExamFeedbacks
     * const examFeedback = await prisma.examFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamFeedbackCreateManyArgs>(args?: SelectSubset<T, ExamFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamFeedback.
     * @param {ExamFeedbackDeleteArgs} args - Arguments to delete one ExamFeedback.
     * @example
     * // Delete one ExamFeedback
     * const ExamFeedback = await prisma.examFeedback.delete({
     *   where: {
     *     // ... filter to delete one ExamFeedback
     *   }
     * })
     * 
     */
    delete<T extends ExamFeedbackDeleteArgs>(args: SelectSubset<T, ExamFeedbackDeleteArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamFeedback.
     * @param {ExamFeedbackUpdateArgs} args - Arguments to update one ExamFeedback.
     * @example
     * // Update one ExamFeedback
     * const examFeedback = await prisma.examFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamFeedbackUpdateArgs>(args: SelectSubset<T, ExamFeedbackUpdateArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamFeedbacks.
     * @param {ExamFeedbackDeleteManyArgs} args - Arguments to filter ExamFeedbacks to delete.
     * @example
     * // Delete a few ExamFeedbacks
     * const { count } = await prisma.examFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamFeedbackDeleteManyArgs>(args?: SelectSubset<T, ExamFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamFeedbacks
     * const examFeedback = await prisma.examFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamFeedbackUpdateManyArgs>(args: SelectSubset<T, ExamFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamFeedback.
     * @param {ExamFeedbackUpsertArgs} args - Arguments to update or create a ExamFeedback.
     * @example
     * // Update or create a ExamFeedback
     * const examFeedback = await prisma.examFeedback.upsert({
     *   create: {
     *     // ... data to create a ExamFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamFeedback we want to update
     *   }
     * })
     */
    upsert<T extends ExamFeedbackUpsertArgs>(args: SelectSubset<T, ExamFeedbackUpsertArgs<ExtArgs>>): Prisma__ExamFeedbackClient<$Result.GetResult<Prisma.$ExamFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamFeedbacks that matches the filter.
     * @param {ExamFeedbackFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const examFeedback = await prisma.examFeedback.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExamFeedbackFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ExamFeedback.
     * @param {ExamFeedbackAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const examFeedback = await prisma.examFeedback.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExamFeedbackAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ExamFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackCountArgs} args - Arguments to filter ExamFeedbacks to count.
     * @example
     * // Count the number of ExamFeedbacks
     * const count = await prisma.examFeedback.count({
     *   where: {
     *     // ... the filter for the ExamFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends ExamFeedbackCountArgs>(
      args?: Subset<T, ExamFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamFeedbackAggregateArgs>(args: Subset<T, ExamFeedbackAggregateArgs>): Prisma.PrismaPromise<GetExamFeedbackAggregateType<T>>

    /**
     * Group by ExamFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: ExamFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamFeedback model
   */
  readonly fields: ExamFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mcqAttempt<T extends McqAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, McqAttemptDefaultArgs<ExtArgs>>): Prisma__McqAttemptClient<$Result.GetResult<Prisma.$McqAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamFeedback model
   */
  interface ExamFeedbackFieldRefs {
    readonly id: FieldRef<"ExamFeedback", 'String'>
    readonly mcqAttemptId: FieldRef<"ExamFeedback", 'String'>
    readonly userId: FieldRef<"ExamFeedback", 'String'>
    readonly overallSummary: FieldRef<"ExamFeedback", 'String'>
    readonly strengths: FieldRef<"ExamFeedback", 'String[]'>
    readonly weaknesses: FieldRef<"ExamFeedback", 'String[]'>
    readonly recommendations: FieldRef<"ExamFeedback", 'String[]'>
    readonly detailedAnalysis: FieldRef<"ExamFeedback", 'Json'>
    readonly userRating: FieldRef<"ExamFeedback", 'Int'>
    readonly createdAt: FieldRef<"ExamFeedback", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamFeedback findUnique
   */
  export type ExamFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ExamFeedback to fetch.
     */
    where: ExamFeedbackWhereUniqueInput
  }

  /**
   * ExamFeedback findUniqueOrThrow
   */
  export type ExamFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ExamFeedback to fetch.
     */
    where: ExamFeedbackWhereUniqueInput
  }

  /**
   * ExamFeedback findFirst
   */
  export type ExamFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ExamFeedback to fetch.
     */
    where?: ExamFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamFeedbacks to fetch.
     */
    orderBy?: ExamFeedbackOrderByWithRelationInput | ExamFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamFeedbacks.
     */
    cursor?: ExamFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamFeedbacks.
     */
    distinct?: ExamFeedbackScalarFieldEnum | ExamFeedbackScalarFieldEnum[]
  }

  /**
   * ExamFeedback findFirstOrThrow
   */
  export type ExamFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ExamFeedback to fetch.
     */
    where?: ExamFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamFeedbacks to fetch.
     */
    orderBy?: ExamFeedbackOrderByWithRelationInput | ExamFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamFeedbacks.
     */
    cursor?: ExamFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamFeedbacks.
     */
    distinct?: ExamFeedbackScalarFieldEnum | ExamFeedbackScalarFieldEnum[]
  }

  /**
   * ExamFeedback findMany
   */
  export type ExamFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which ExamFeedbacks to fetch.
     */
    where?: ExamFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamFeedbacks to fetch.
     */
    orderBy?: ExamFeedbackOrderByWithRelationInput | ExamFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamFeedbacks.
     */
    cursor?: ExamFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamFeedbacks.
     */
    skip?: number
    distinct?: ExamFeedbackScalarFieldEnum | ExamFeedbackScalarFieldEnum[]
  }

  /**
   * ExamFeedback create
   */
  export type ExamFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamFeedback.
     */
    data: XOR<ExamFeedbackCreateInput, ExamFeedbackUncheckedCreateInput>
  }

  /**
   * ExamFeedback createMany
   */
  export type ExamFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamFeedbacks.
     */
    data: ExamFeedbackCreateManyInput | ExamFeedbackCreateManyInput[]
  }

  /**
   * ExamFeedback update
   */
  export type ExamFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamFeedback.
     */
    data: XOR<ExamFeedbackUpdateInput, ExamFeedbackUncheckedUpdateInput>
    /**
     * Choose, which ExamFeedback to update.
     */
    where: ExamFeedbackWhereUniqueInput
  }

  /**
   * ExamFeedback updateMany
   */
  export type ExamFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamFeedbacks.
     */
    data: XOR<ExamFeedbackUpdateManyMutationInput, ExamFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which ExamFeedbacks to update
     */
    where?: ExamFeedbackWhereInput
    /**
     * Limit how many ExamFeedbacks to update.
     */
    limit?: number
  }

  /**
   * ExamFeedback upsert
   */
  export type ExamFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamFeedback to update in case it exists.
     */
    where: ExamFeedbackWhereUniqueInput
    /**
     * In case the ExamFeedback found by the `where` argument doesn't exist, create a new ExamFeedback with this data.
     */
    create: XOR<ExamFeedbackCreateInput, ExamFeedbackUncheckedCreateInput>
    /**
     * In case the ExamFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamFeedbackUpdateInput, ExamFeedbackUncheckedUpdateInput>
  }

  /**
   * ExamFeedback delete
   */
  export type ExamFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
    /**
     * Filter which ExamFeedback to delete.
     */
    where: ExamFeedbackWhereUniqueInput
  }

  /**
   * ExamFeedback deleteMany
   */
  export type ExamFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamFeedbacks to delete
     */
    where?: ExamFeedbackWhereInput
    /**
     * Limit how many ExamFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * ExamFeedback findRaw
   */
  export type ExamFeedbackFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExamFeedback aggregateRaw
   */
  export type ExamFeedbackAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExamFeedback without action
   */
  export type ExamFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamFeedback
     */
    select?: ExamFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamFeedback
     */
    omit?: ExamFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model CreditPlan
   */

  export type AggregateCreditPlan = {
    _count: CreditPlanCountAggregateOutputType | null
    _avg: CreditPlanAvgAggregateOutputType | null
    _sum: CreditPlanSumAggregateOutputType | null
    _min: CreditPlanMinAggregateOutputType | null
    _max: CreditPlanMaxAggregateOutputType | null
  }

  export type CreditPlanAvgAggregateOutputType = {
    credit: number | null
    price: number | null
    discount: number | null
    save: number | null
    bonus: number | null
  }

  export type CreditPlanSumAggregateOutputType = {
    credit: number | null
    price: number | null
    discount: number | null
    save: number | null
    bonus: number | null
  }

  export type CreditPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    credit: number | null
    price: number | null
    discount: number | null
    save: number | null
    bonus: number | null
    status: string | null
    isPopular: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    credit: number | null
    price: number | null
    discount: number | null
    save: number | null
    bonus: number | null
    status: string | null
    isPopular: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditPlanCountAggregateOutputType = {
    id: number
    name: number
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status: number
    isPopular: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreditPlanAvgAggregateInputType = {
    credit?: true
    price?: true
    discount?: true
    save?: true
    bonus?: true
  }

  export type CreditPlanSumAggregateInputType = {
    credit?: true
    price?: true
    discount?: true
    save?: true
    bonus?: true
  }

  export type CreditPlanMinAggregateInputType = {
    id?: true
    name?: true
    credit?: true
    price?: true
    discount?: true
    save?: true
    bonus?: true
    status?: true
    isPopular?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditPlanMaxAggregateInputType = {
    id?: true
    name?: true
    credit?: true
    price?: true
    discount?: true
    save?: true
    bonus?: true
    status?: true
    isPopular?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditPlanCountAggregateInputType = {
    id?: true
    name?: true
    credit?: true
    price?: true
    discount?: true
    save?: true
    bonus?: true
    status?: true
    isPopular?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPlan to aggregate.
     */
    where?: CreditPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPlans to fetch.
     */
    orderBy?: CreditPlanOrderByWithRelationInput | CreditPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditPlans
    **/
    _count?: true | CreditPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditPlanMaxAggregateInputType
  }

  export type GetCreditPlanAggregateType<T extends CreditPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditPlan[P]>
      : GetScalarType<T[P], AggregateCreditPlan[P]>
  }




  export type CreditPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditPlanWhereInput
    orderBy?: CreditPlanOrderByWithAggregationInput | CreditPlanOrderByWithAggregationInput[]
    by: CreditPlanScalarFieldEnum[] | CreditPlanScalarFieldEnum
    having?: CreditPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditPlanCountAggregateInputType | true
    _avg?: CreditPlanAvgAggregateInputType
    _sum?: CreditPlanSumAggregateInputType
    _min?: CreditPlanMinAggregateInputType
    _max?: CreditPlanMaxAggregateInputType
  }

  export type CreditPlanGroupByOutputType = {
    id: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status: string
    isPopular: boolean
    createdAt: Date
    updatedAt: Date
    _count: CreditPlanCountAggregateOutputType | null
    _avg: CreditPlanAvgAggregateOutputType | null
    _sum: CreditPlanSumAggregateOutputType | null
    _min: CreditPlanMinAggregateOutputType | null
    _max: CreditPlanMaxAggregateOutputType | null
  }

  type GetCreditPlanGroupByPayload<T extends CreditPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditPlanGroupByOutputType[P]>
            : GetScalarType<T[P], CreditPlanGroupByOutputType[P]>
        }
      >
    >


  export type CreditPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    credit?: boolean
    price?: boolean
    discount?: boolean
    save?: boolean
    bonus?: boolean
    status?: boolean
    isPopular?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | CreditPlan$transactionsArgs<ExtArgs>
    _count?: boolean | CreditPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditPlan"]>



  export type CreditPlanSelectScalar = {
    id?: boolean
    name?: boolean
    credit?: boolean
    price?: boolean
    discount?: boolean
    save?: boolean
    bonus?: boolean
    status?: boolean
    isPopular?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "credit" | "price" | "discount" | "save" | "bonus" | "status" | "isPopular" | "createdAt" | "updatedAt", ExtArgs["result"]["creditPlan"]>
  export type CreditPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CreditPlan$transactionsArgs<ExtArgs>
    _count?: boolean | CreditPlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CreditPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditPlan"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      credit: number
      price: number
      discount: number
      save: number
      bonus: number
      status: string
      isPopular: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creditPlan"]>
    composites: {}
  }

  type CreditPlanGetPayload<S extends boolean | null | undefined | CreditPlanDefaultArgs> = $Result.GetResult<Prisma.$CreditPlanPayload, S>

  type CreditPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditPlanCountAggregateInputType | true
    }

  export interface CreditPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditPlan'], meta: { name: 'CreditPlan' } }
    /**
     * Find zero or one CreditPlan that matches the filter.
     * @param {CreditPlanFindUniqueArgs} args - Arguments to find a CreditPlan
     * @example
     * // Get one CreditPlan
     * const creditPlan = await prisma.creditPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditPlanFindUniqueArgs>(args: SelectSubset<T, CreditPlanFindUniqueArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditPlanFindUniqueOrThrowArgs} args - Arguments to find a CreditPlan
     * @example
     * // Get one CreditPlan
     * const creditPlan = await prisma.creditPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanFindFirstArgs} args - Arguments to find a CreditPlan
     * @example
     * // Get one CreditPlan
     * const creditPlan = await prisma.creditPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditPlanFindFirstArgs>(args?: SelectSubset<T, CreditPlanFindFirstArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanFindFirstOrThrowArgs} args - Arguments to find a CreditPlan
     * @example
     * // Get one CreditPlan
     * const creditPlan = await prisma.creditPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditPlans
     * const creditPlans = await prisma.creditPlan.findMany()
     * 
     * // Get first 10 CreditPlans
     * const creditPlans = await prisma.creditPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditPlanWithIdOnly = await prisma.creditPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditPlanFindManyArgs>(args?: SelectSubset<T, CreditPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditPlan.
     * @param {CreditPlanCreateArgs} args - Arguments to create a CreditPlan.
     * @example
     * // Create one CreditPlan
     * const CreditPlan = await prisma.creditPlan.create({
     *   data: {
     *     // ... data to create a CreditPlan
     *   }
     * })
     * 
     */
    create<T extends CreditPlanCreateArgs>(args: SelectSubset<T, CreditPlanCreateArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditPlans.
     * @param {CreditPlanCreateManyArgs} args - Arguments to create many CreditPlans.
     * @example
     * // Create many CreditPlans
     * const creditPlan = await prisma.creditPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditPlanCreateManyArgs>(args?: SelectSubset<T, CreditPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CreditPlan.
     * @param {CreditPlanDeleteArgs} args - Arguments to delete one CreditPlan.
     * @example
     * // Delete one CreditPlan
     * const CreditPlan = await prisma.creditPlan.delete({
     *   where: {
     *     // ... filter to delete one CreditPlan
     *   }
     * })
     * 
     */
    delete<T extends CreditPlanDeleteArgs>(args: SelectSubset<T, CreditPlanDeleteArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditPlan.
     * @param {CreditPlanUpdateArgs} args - Arguments to update one CreditPlan.
     * @example
     * // Update one CreditPlan
     * const creditPlan = await prisma.creditPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditPlanUpdateArgs>(args: SelectSubset<T, CreditPlanUpdateArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditPlans.
     * @param {CreditPlanDeleteManyArgs} args - Arguments to filter CreditPlans to delete.
     * @example
     * // Delete a few CreditPlans
     * const { count } = await prisma.creditPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditPlanDeleteManyArgs>(args?: SelectSubset<T, CreditPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditPlans
     * const creditPlan = await prisma.creditPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditPlanUpdateManyArgs>(args: SelectSubset<T, CreditPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditPlan.
     * @param {CreditPlanUpsertArgs} args - Arguments to update or create a CreditPlan.
     * @example
     * // Update or create a CreditPlan
     * const creditPlan = await prisma.creditPlan.upsert({
     *   create: {
     *     // ... data to create a CreditPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditPlan we want to update
     *   }
     * })
     */
    upsert<T extends CreditPlanUpsertArgs>(args: SelectSubset<T, CreditPlanUpsertArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditPlans that matches the filter.
     * @param {CreditPlanFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const creditPlan = await prisma.creditPlan.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CreditPlanFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CreditPlan.
     * @param {CreditPlanAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const creditPlan = await prisma.creditPlan.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CreditPlanAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CreditPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanCountArgs} args - Arguments to filter CreditPlans to count.
     * @example
     * // Count the number of CreditPlans
     * const count = await prisma.creditPlan.count({
     *   where: {
     *     // ... the filter for the CreditPlans we want to count
     *   }
     * })
    **/
    count<T extends CreditPlanCountArgs>(
      args?: Subset<T, CreditPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditPlanAggregateArgs>(args: Subset<T, CreditPlanAggregateArgs>): Prisma.PrismaPromise<GetCreditPlanAggregateType<T>>

    /**
     * Group by CreditPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditPlanGroupByArgs['orderBy'] }
        : { orderBy?: CreditPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditPlan model
   */
  readonly fields: CreditPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends CreditPlan$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CreditPlan$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditPlan model
   */
  interface CreditPlanFieldRefs {
    readonly id: FieldRef<"CreditPlan", 'String'>
    readonly name: FieldRef<"CreditPlan", 'String'>
    readonly credit: FieldRef<"CreditPlan", 'Int'>
    readonly price: FieldRef<"CreditPlan", 'Int'>
    readonly discount: FieldRef<"CreditPlan", 'Int'>
    readonly save: FieldRef<"CreditPlan", 'Int'>
    readonly bonus: FieldRef<"CreditPlan", 'Int'>
    readonly status: FieldRef<"CreditPlan", 'String'>
    readonly isPopular: FieldRef<"CreditPlan", 'Boolean'>
    readonly createdAt: FieldRef<"CreditPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"CreditPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditPlan findUnique
   */
  export type CreditPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreditPlan to fetch.
     */
    where: CreditPlanWhereUniqueInput
  }

  /**
   * CreditPlan findUniqueOrThrow
   */
  export type CreditPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreditPlan to fetch.
     */
    where: CreditPlanWhereUniqueInput
  }

  /**
   * CreditPlan findFirst
   */
  export type CreditPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreditPlan to fetch.
     */
    where?: CreditPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPlans to fetch.
     */
    orderBy?: CreditPlanOrderByWithRelationInput | CreditPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPlans.
     */
    cursor?: CreditPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPlans.
     */
    distinct?: CreditPlanScalarFieldEnum | CreditPlanScalarFieldEnum[]
  }

  /**
   * CreditPlan findFirstOrThrow
   */
  export type CreditPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreditPlan to fetch.
     */
    where?: CreditPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPlans to fetch.
     */
    orderBy?: CreditPlanOrderByWithRelationInput | CreditPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditPlans.
     */
    cursor?: CreditPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditPlans.
     */
    distinct?: CreditPlanScalarFieldEnum | CreditPlanScalarFieldEnum[]
  }

  /**
   * CreditPlan findMany
   */
  export type CreditPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter, which CreditPlans to fetch.
     */
    where?: CreditPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditPlans to fetch.
     */
    orderBy?: CreditPlanOrderByWithRelationInput | CreditPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditPlans.
     */
    cursor?: CreditPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditPlans.
     */
    skip?: number
    distinct?: CreditPlanScalarFieldEnum | CreditPlanScalarFieldEnum[]
  }

  /**
   * CreditPlan create
   */
  export type CreditPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditPlan.
     */
    data: XOR<CreditPlanCreateInput, CreditPlanUncheckedCreateInput>
  }

  /**
   * CreditPlan createMany
   */
  export type CreditPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditPlans.
     */
    data: CreditPlanCreateManyInput | CreditPlanCreateManyInput[]
  }

  /**
   * CreditPlan update
   */
  export type CreditPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditPlan.
     */
    data: XOR<CreditPlanUpdateInput, CreditPlanUncheckedUpdateInput>
    /**
     * Choose, which CreditPlan to update.
     */
    where: CreditPlanWhereUniqueInput
  }

  /**
   * CreditPlan updateMany
   */
  export type CreditPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditPlans.
     */
    data: XOR<CreditPlanUpdateManyMutationInput, CreditPlanUncheckedUpdateManyInput>
    /**
     * Filter which CreditPlans to update
     */
    where?: CreditPlanWhereInput
    /**
     * Limit how many CreditPlans to update.
     */
    limit?: number
  }

  /**
   * CreditPlan upsert
   */
  export type CreditPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditPlan to update in case it exists.
     */
    where: CreditPlanWhereUniqueInput
    /**
     * In case the CreditPlan found by the `where` argument doesn't exist, create a new CreditPlan with this data.
     */
    create: XOR<CreditPlanCreateInput, CreditPlanUncheckedCreateInput>
    /**
     * In case the CreditPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditPlanUpdateInput, CreditPlanUncheckedUpdateInput>
  }

  /**
   * CreditPlan delete
   */
  export type CreditPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
    /**
     * Filter which CreditPlan to delete.
     */
    where: CreditPlanWhereUniqueInput
  }

  /**
   * CreditPlan deleteMany
   */
  export type CreditPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditPlans to delete
     */
    where?: CreditPlanWhereInput
    /**
     * Limit how many CreditPlans to delete.
     */
    limit?: number
  }

  /**
   * CreditPlan findRaw
   */
  export type CreditPlanFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CreditPlan aggregateRaw
   */
  export type CreditPlanAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CreditPlan.transactions
   */
  export type CreditPlan$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CreditPlan without action
   */
  export type CreditPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditPlan
     */
    select?: CreditPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditPlan
     */
    omit?: CreditPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditPlanInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: number | null
    type: string | null
    method: string | null
    status: string | null
    userId: string | null
    creditPlanId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: number | null
    type: string | null
    method: string | null
    status: string | null
    userId: string | null
    creditPlanId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    transactionId: number
    amount: number
    type: number
    method: number
    status: number
    userId: number
    creditPlanId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    type?: true
    method?: true
    status?: true
    userId?: true
    creditPlanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    type?: true
    method?: true
    status?: true
    userId?: true
    creditPlanId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    type?: true
    method?: true
    status?: true
    userId?: true
    creditPlanId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    transactionId: string
    amount: number
    type: string
    method: string
    status: string
    userId: string
    creditPlanId: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    userId?: boolean
    creditPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    creditPlan?: boolean | CreditPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    userId?: boolean
    creditPlanId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "amount" | "type" | "method" | "status" | "userId" | "creditPlanId" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    creditPlan?: boolean | CreditPlanDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      creditPlan: Prisma.$CreditPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      amount: number
      type: string
      method: string
      status: string
      userId: string
      creditPlanId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * @param {TransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transaction = await prisma.transaction.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TransactionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Transaction.
     * @param {TransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transaction = await prisma.transaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TransactionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creditPlan<T extends CreditPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditPlanDefaultArgs<ExtArgs>>): Prisma__CreditPlanClient<$Result.GetResult<Prisma.$CreditPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly transactionId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly method: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly creditPlanId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction findRaw
   */
  export type TransactionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction aggregateRaw
   */
  export type TransactionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model ExamPlan
   */

  export type AggregateExamPlan = {
    _count: ExamPlanCountAggregateOutputType | null
    _avg: ExamPlanAvgAggregateOutputType | null
    _sum: ExamPlanSumAggregateOutputType | null
    _min: ExamPlanMinAggregateOutputType | null
    _max: ExamPlanMaxAggregateOutputType | null
  }

  export type ExamPlanAvgAggregateOutputType = {
    credit: number | null
    mcqs: number | null
    exams: number | null
    attempts: number | null
  }

  export type ExamPlanSumAggregateOutputType = {
    credit: number | null
    mcqs: number | null
    exams: number | null
    attempts: number | null
  }

  export type ExamPlanMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    credit: number | null
    mcqs: number | null
    exams: number | null
    attempts: number | null
    enableDownloadReport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamPlanMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    credit: number | null
    mcqs: number | null
    exams: number | null
    attempts: number | null
    enableDownloadReport: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamPlanCountAggregateOutputType = {
    id: number
    title: number
    description: number
    credit: number
    mcqs: number
    exams: number
    attempts: number
    features: number
    aiFeedbackFeatures: number
    enableDownloadReport: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamPlanAvgAggregateInputType = {
    credit?: true
    mcqs?: true
    exams?: true
    attempts?: true
  }

  export type ExamPlanSumAggregateInputType = {
    credit?: true
    mcqs?: true
    exams?: true
    attempts?: true
  }

  export type ExamPlanMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    credit?: true
    mcqs?: true
    exams?: true
    attempts?: true
    enableDownloadReport?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamPlanMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    credit?: true
    mcqs?: true
    exams?: true
    attempts?: true
    enableDownloadReport?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamPlanCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    credit?: true
    mcqs?: true
    exams?: true
    attempts?: true
    features?: true
    aiFeedbackFeatures?: true
    enableDownloadReport?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamPlan to aggregate.
     */
    where?: ExamPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamPlans to fetch.
     */
    orderBy?: ExamPlanOrderByWithRelationInput | ExamPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamPlans
    **/
    _count?: true | ExamPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamPlanMaxAggregateInputType
  }

  export type GetExamPlanAggregateType<T extends ExamPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateExamPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamPlan[P]>
      : GetScalarType<T[P], AggregateExamPlan[P]>
  }




  export type ExamPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamPlanWhereInput
    orderBy?: ExamPlanOrderByWithAggregationInput | ExamPlanOrderByWithAggregationInput[]
    by: ExamPlanScalarFieldEnum[] | ExamPlanScalarFieldEnum
    having?: ExamPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamPlanCountAggregateInputType | true
    _avg?: ExamPlanAvgAggregateInputType
    _sum?: ExamPlanSumAggregateInputType
    _min?: ExamPlanMinAggregateInputType
    _max?: ExamPlanMaxAggregateInputType
  }

  export type ExamPlanGroupByOutputType = {
    id: string
    title: string
    description: string
    credit: number
    mcqs: number
    exams: number
    attempts: number
    features: string[]
    aiFeedbackFeatures: string[]
    enableDownloadReport: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExamPlanCountAggregateOutputType | null
    _avg: ExamPlanAvgAggregateOutputType | null
    _sum: ExamPlanSumAggregateOutputType | null
    _min: ExamPlanMinAggregateOutputType | null
    _max: ExamPlanMaxAggregateOutputType | null
  }

  type GetExamPlanGroupByPayload<T extends ExamPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ExamPlanGroupByOutputType[P]>
        }
      >
    >


  export type ExamPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    credit?: boolean
    mcqs?: boolean
    exams?: boolean
    attempts?: boolean
    features?: boolean
    aiFeedbackFeatures?: boolean
    enableDownloadReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchases?: boolean | ExamPlan$purchasesArgs<ExtArgs>
    _count?: boolean | ExamPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examPlan"]>



  export type ExamPlanSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    credit?: boolean
    mcqs?: boolean
    exams?: boolean
    attempts?: boolean
    features?: boolean
    aiFeedbackFeatures?: boolean
    enableDownloadReport?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "credit" | "mcqs" | "exams" | "attempts" | "features" | "aiFeedbackFeatures" | "enableDownloadReport" | "createdAt" | "updatedAt", ExtArgs["result"]["examPlan"]>
  export type ExamPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | ExamPlan$purchasesArgs<ExtArgs>
    _count?: boolean | ExamPlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExamPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamPlan"
    objects: {
      purchases: Prisma.$PlanPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      credit: number
      mcqs: number
      exams: number
      attempts: number
      features: string[]
      aiFeedbackFeatures: string[]
      enableDownloadReport: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examPlan"]>
    composites: {}
  }

  type ExamPlanGetPayload<S extends boolean | null | undefined | ExamPlanDefaultArgs> = $Result.GetResult<Prisma.$ExamPlanPayload, S>

  type ExamPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamPlanCountAggregateInputType | true
    }

  export interface ExamPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamPlan'], meta: { name: 'ExamPlan' } }
    /**
     * Find zero or one ExamPlan that matches the filter.
     * @param {ExamPlanFindUniqueArgs} args - Arguments to find a ExamPlan
     * @example
     * // Get one ExamPlan
     * const examPlan = await prisma.examPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamPlanFindUniqueArgs>(args: SelectSubset<T, ExamPlanFindUniqueArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamPlanFindUniqueOrThrowArgs} args - Arguments to find a ExamPlan
     * @example
     * // Get one ExamPlan
     * const examPlan = await prisma.examPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanFindFirstArgs} args - Arguments to find a ExamPlan
     * @example
     * // Get one ExamPlan
     * const examPlan = await prisma.examPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamPlanFindFirstArgs>(args?: SelectSubset<T, ExamPlanFindFirstArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanFindFirstOrThrowArgs} args - Arguments to find a ExamPlan
     * @example
     * // Get one ExamPlan
     * const examPlan = await prisma.examPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamPlans
     * const examPlans = await prisma.examPlan.findMany()
     * 
     * // Get first 10 ExamPlans
     * const examPlans = await prisma.examPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examPlanWithIdOnly = await prisma.examPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamPlanFindManyArgs>(args?: SelectSubset<T, ExamPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamPlan.
     * @param {ExamPlanCreateArgs} args - Arguments to create a ExamPlan.
     * @example
     * // Create one ExamPlan
     * const ExamPlan = await prisma.examPlan.create({
     *   data: {
     *     // ... data to create a ExamPlan
     *   }
     * })
     * 
     */
    create<T extends ExamPlanCreateArgs>(args: SelectSubset<T, ExamPlanCreateArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamPlans.
     * @param {ExamPlanCreateManyArgs} args - Arguments to create many ExamPlans.
     * @example
     * // Create many ExamPlans
     * const examPlan = await prisma.examPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamPlanCreateManyArgs>(args?: SelectSubset<T, ExamPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamPlan.
     * @param {ExamPlanDeleteArgs} args - Arguments to delete one ExamPlan.
     * @example
     * // Delete one ExamPlan
     * const ExamPlan = await prisma.examPlan.delete({
     *   where: {
     *     // ... filter to delete one ExamPlan
     *   }
     * })
     * 
     */
    delete<T extends ExamPlanDeleteArgs>(args: SelectSubset<T, ExamPlanDeleteArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamPlan.
     * @param {ExamPlanUpdateArgs} args - Arguments to update one ExamPlan.
     * @example
     * // Update one ExamPlan
     * const examPlan = await prisma.examPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamPlanUpdateArgs>(args: SelectSubset<T, ExamPlanUpdateArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamPlans.
     * @param {ExamPlanDeleteManyArgs} args - Arguments to filter ExamPlans to delete.
     * @example
     * // Delete a few ExamPlans
     * const { count } = await prisma.examPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamPlanDeleteManyArgs>(args?: SelectSubset<T, ExamPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamPlans
     * const examPlan = await prisma.examPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamPlanUpdateManyArgs>(args: SelectSubset<T, ExamPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamPlan.
     * @param {ExamPlanUpsertArgs} args - Arguments to update or create a ExamPlan.
     * @example
     * // Update or create a ExamPlan
     * const examPlan = await prisma.examPlan.upsert({
     *   create: {
     *     // ... data to create a ExamPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamPlan we want to update
     *   }
     * })
     */
    upsert<T extends ExamPlanUpsertArgs>(args: SelectSubset<T, ExamPlanUpsertArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamPlans that matches the filter.
     * @param {ExamPlanFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const examPlan = await prisma.examPlan.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExamPlanFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ExamPlan.
     * @param {ExamPlanAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const examPlan = await prisma.examPlan.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExamPlanAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ExamPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanCountArgs} args - Arguments to filter ExamPlans to count.
     * @example
     * // Count the number of ExamPlans
     * const count = await prisma.examPlan.count({
     *   where: {
     *     // ... the filter for the ExamPlans we want to count
     *   }
     * })
    **/
    count<T extends ExamPlanCountArgs>(
      args?: Subset<T, ExamPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamPlanAggregateArgs>(args: Subset<T, ExamPlanAggregateArgs>): Prisma.PrismaPromise<GetExamPlanAggregateType<T>>

    /**
     * Group by ExamPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamPlanGroupByArgs['orderBy'] }
        : { orderBy?: ExamPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamPlan model
   */
  readonly fields: ExamPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends ExamPlan$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, ExamPlan$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamPlan model
   */
  interface ExamPlanFieldRefs {
    readonly id: FieldRef<"ExamPlan", 'String'>
    readonly title: FieldRef<"ExamPlan", 'String'>
    readonly description: FieldRef<"ExamPlan", 'String'>
    readonly credit: FieldRef<"ExamPlan", 'Int'>
    readonly mcqs: FieldRef<"ExamPlan", 'Int'>
    readonly exams: FieldRef<"ExamPlan", 'Int'>
    readonly attempts: FieldRef<"ExamPlan", 'Int'>
    readonly features: FieldRef<"ExamPlan", 'String[]'>
    readonly aiFeedbackFeatures: FieldRef<"ExamPlan", 'String[]'>
    readonly enableDownloadReport: FieldRef<"ExamPlan", 'Boolean'>
    readonly createdAt: FieldRef<"ExamPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamPlan findUnique
   */
  export type ExamPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter, which ExamPlan to fetch.
     */
    where: ExamPlanWhereUniqueInput
  }

  /**
   * ExamPlan findUniqueOrThrow
   */
  export type ExamPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter, which ExamPlan to fetch.
     */
    where: ExamPlanWhereUniqueInput
  }

  /**
   * ExamPlan findFirst
   */
  export type ExamPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter, which ExamPlan to fetch.
     */
    where?: ExamPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamPlans to fetch.
     */
    orderBy?: ExamPlanOrderByWithRelationInput | ExamPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamPlans.
     */
    cursor?: ExamPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamPlans.
     */
    distinct?: ExamPlanScalarFieldEnum | ExamPlanScalarFieldEnum[]
  }

  /**
   * ExamPlan findFirstOrThrow
   */
  export type ExamPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter, which ExamPlan to fetch.
     */
    where?: ExamPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamPlans to fetch.
     */
    orderBy?: ExamPlanOrderByWithRelationInput | ExamPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamPlans.
     */
    cursor?: ExamPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamPlans.
     */
    distinct?: ExamPlanScalarFieldEnum | ExamPlanScalarFieldEnum[]
  }

  /**
   * ExamPlan findMany
   */
  export type ExamPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter, which ExamPlans to fetch.
     */
    where?: ExamPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamPlans to fetch.
     */
    orderBy?: ExamPlanOrderByWithRelationInput | ExamPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamPlans.
     */
    cursor?: ExamPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamPlans.
     */
    skip?: number
    distinct?: ExamPlanScalarFieldEnum | ExamPlanScalarFieldEnum[]
  }

  /**
   * ExamPlan create
   */
  export type ExamPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamPlan.
     */
    data: XOR<ExamPlanCreateInput, ExamPlanUncheckedCreateInput>
  }

  /**
   * ExamPlan createMany
   */
  export type ExamPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamPlans.
     */
    data: ExamPlanCreateManyInput | ExamPlanCreateManyInput[]
  }

  /**
   * ExamPlan update
   */
  export type ExamPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamPlan.
     */
    data: XOR<ExamPlanUpdateInput, ExamPlanUncheckedUpdateInput>
    /**
     * Choose, which ExamPlan to update.
     */
    where: ExamPlanWhereUniqueInput
  }

  /**
   * ExamPlan updateMany
   */
  export type ExamPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamPlans.
     */
    data: XOR<ExamPlanUpdateManyMutationInput, ExamPlanUncheckedUpdateManyInput>
    /**
     * Filter which ExamPlans to update
     */
    where?: ExamPlanWhereInput
    /**
     * Limit how many ExamPlans to update.
     */
    limit?: number
  }

  /**
   * ExamPlan upsert
   */
  export type ExamPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamPlan to update in case it exists.
     */
    where: ExamPlanWhereUniqueInput
    /**
     * In case the ExamPlan found by the `where` argument doesn't exist, create a new ExamPlan with this data.
     */
    create: XOR<ExamPlanCreateInput, ExamPlanUncheckedCreateInput>
    /**
     * In case the ExamPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamPlanUpdateInput, ExamPlanUncheckedUpdateInput>
  }

  /**
   * ExamPlan delete
   */
  export type ExamPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
    /**
     * Filter which ExamPlan to delete.
     */
    where: ExamPlanWhereUniqueInput
  }

  /**
   * ExamPlan deleteMany
   */
  export type ExamPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamPlans to delete
     */
    where?: ExamPlanWhereInput
    /**
     * Limit how many ExamPlans to delete.
     */
    limit?: number
  }

  /**
   * ExamPlan findRaw
   */
  export type ExamPlanFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExamPlan aggregateRaw
   */
  export type ExamPlanAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ExamPlan.purchases
   */
  export type ExamPlan$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    where?: PlanPurchaseWhereInput
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    cursor?: PlanPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanPurchaseScalarFieldEnum | PlanPurchaseScalarFieldEnum[]
  }

  /**
   * ExamPlan without action
   */
  export type ExamPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamPlan
     */
    select?: ExamPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamPlan
     */
    omit?: ExamPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamPlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanPurchase
   */

  export type AggregatePlanPurchase = {
    _count: PlanPurchaseCountAggregateOutputType | null
    _avg: PlanPurchaseAvgAggregateOutputType | null
    _sum: PlanPurchaseSumAggregateOutputType | null
    _min: PlanPurchaseMinAggregateOutputType | null
    _max: PlanPurchaseMaxAggregateOutputType | null
  }

  export type PlanPurchaseAvgAggregateOutputType = {
    usedMcqs: number | null
    usedExams: number | null
    usedAttempts: number | null
  }

  export type PlanPurchaseSumAggregateOutputType = {
    usedMcqs: number | null
    usedExams: number | null
    usedAttempts: number | null
  }

  export type PlanPurchaseMinAggregateOutputType = {
    id: string | null
    usedMcqs: number | null
    usedExams: number | null
    usedAttempts: number | null
    status: string | null
    userId: string | null
    planId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPurchaseMaxAggregateOutputType = {
    id: string | null
    usedMcqs: number | null
    usedExams: number | null
    usedAttempts: number | null
    status: string | null
    userId: string | null
    planId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanPurchaseCountAggregateOutputType = {
    id: number
    usedMcqs: number
    usedExams: number
    usedAttempts: number
    status: number
    userId: number
    planId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanPurchaseAvgAggregateInputType = {
    usedMcqs?: true
    usedExams?: true
    usedAttempts?: true
  }

  export type PlanPurchaseSumAggregateInputType = {
    usedMcqs?: true
    usedExams?: true
    usedAttempts?: true
  }

  export type PlanPurchaseMinAggregateInputType = {
    id?: true
    usedMcqs?: true
    usedExams?: true
    usedAttempts?: true
    status?: true
    userId?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPurchaseMaxAggregateInputType = {
    id?: true
    usedMcqs?: true
    usedExams?: true
    usedAttempts?: true
    status?: true
    userId?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanPurchaseCountAggregateInputType = {
    id?: true
    usedMcqs?: true
    usedExams?: true
    usedAttempts?: true
    status?: true
    userId?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPurchase to aggregate.
     */
    where?: PlanPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPurchases to fetch.
     */
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanPurchases
    **/
    _count?: true | PlanPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanPurchaseMaxAggregateInputType
  }

  export type GetPlanPurchaseAggregateType<T extends PlanPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanPurchase[P]>
      : GetScalarType<T[P], AggregatePlanPurchase[P]>
  }




  export type PlanPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanPurchaseWhereInput
    orderBy?: PlanPurchaseOrderByWithAggregationInput | PlanPurchaseOrderByWithAggregationInput[]
    by: PlanPurchaseScalarFieldEnum[] | PlanPurchaseScalarFieldEnum
    having?: PlanPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanPurchaseCountAggregateInputType | true
    _avg?: PlanPurchaseAvgAggregateInputType
    _sum?: PlanPurchaseSumAggregateInputType
    _min?: PlanPurchaseMinAggregateInputType
    _max?: PlanPurchaseMaxAggregateInputType
  }

  export type PlanPurchaseGroupByOutputType = {
    id: string
    usedMcqs: number
    usedExams: number
    usedAttempts: number
    status: string
    userId: string
    planId: string
    createdAt: Date
    updatedAt: Date
    _count: PlanPurchaseCountAggregateOutputType | null
    _avg: PlanPurchaseAvgAggregateOutputType | null
    _sum: PlanPurchaseSumAggregateOutputType | null
    _min: PlanPurchaseMinAggregateOutputType | null
    _max: PlanPurchaseMaxAggregateOutputType | null
  }

  type GetPlanPurchaseGroupByPayload<T extends PlanPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PlanPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PlanPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usedMcqs?: boolean
    usedExams?: boolean
    usedAttempts?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | ExamPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planPurchase"]>



  export type PlanPurchaseSelectScalar = {
    id?: boolean
    usedMcqs?: boolean
    usedExams?: boolean
    usedAttempts?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usedMcqs" | "usedExams" | "usedAttempts" | "status" | "userId" | "planId" | "createdAt" | "updatedAt", ExtArgs["result"]["planPurchase"]>
  export type PlanPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | ExamPlanDefaultArgs<ExtArgs>
  }

  export type $PlanPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanPurchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$ExamPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usedMcqs: number
      usedExams: number
      usedAttempts: number
      status: string
      userId: string
      planId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planPurchase"]>
    composites: {}
  }

  type PlanPurchaseGetPayload<S extends boolean | null | undefined | PlanPurchaseDefaultArgs> = $Result.GetResult<Prisma.$PlanPurchasePayload, S>

  type PlanPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanPurchaseCountAggregateInputType | true
    }

  export interface PlanPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanPurchase'], meta: { name: 'PlanPurchase' } }
    /**
     * Find zero or one PlanPurchase that matches the filter.
     * @param {PlanPurchaseFindUniqueArgs} args - Arguments to find a PlanPurchase
     * @example
     * // Get one PlanPurchase
     * const planPurchase = await prisma.planPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanPurchaseFindUniqueArgs>(args: SelectSubset<T, PlanPurchaseFindUniqueArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanPurchaseFindUniqueOrThrowArgs} args - Arguments to find a PlanPurchase
     * @example
     * // Get one PlanPurchase
     * const planPurchase = await prisma.planPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseFindFirstArgs} args - Arguments to find a PlanPurchase
     * @example
     * // Get one PlanPurchase
     * const planPurchase = await prisma.planPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanPurchaseFindFirstArgs>(args?: SelectSubset<T, PlanPurchaseFindFirstArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseFindFirstOrThrowArgs} args - Arguments to find a PlanPurchase
     * @example
     * // Get one PlanPurchase
     * const planPurchase = await prisma.planPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanPurchases
     * const planPurchases = await prisma.planPurchase.findMany()
     * 
     * // Get first 10 PlanPurchases
     * const planPurchases = await prisma.planPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planPurchaseWithIdOnly = await prisma.planPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanPurchaseFindManyArgs>(args?: SelectSubset<T, PlanPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanPurchase.
     * @param {PlanPurchaseCreateArgs} args - Arguments to create a PlanPurchase.
     * @example
     * // Create one PlanPurchase
     * const PlanPurchase = await prisma.planPurchase.create({
     *   data: {
     *     // ... data to create a PlanPurchase
     *   }
     * })
     * 
     */
    create<T extends PlanPurchaseCreateArgs>(args: SelectSubset<T, PlanPurchaseCreateArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanPurchases.
     * @param {PlanPurchaseCreateManyArgs} args - Arguments to create many PlanPurchases.
     * @example
     * // Create many PlanPurchases
     * const planPurchase = await prisma.planPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanPurchaseCreateManyArgs>(args?: SelectSubset<T, PlanPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanPurchase.
     * @param {PlanPurchaseDeleteArgs} args - Arguments to delete one PlanPurchase.
     * @example
     * // Delete one PlanPurchase
     * const PlanPurchase = await prisma.planPurchase.delete({
     *   where: {
     *     // ... filter to delete one PlanPurchase
     *   }
     * })
     * 
     */
    delete<T extends PlanPurchaseDeleteArgs>(args: SelectSubset<T, PlanPurchaseDeleteArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanPurchase.
     * @param {PlanPurchaseUpdateArgs} args - Arguments to update one PlanPurchase.
     * @example
     * // Update one PlanPurchase
     * const planPurchase = await prisma.planPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanPurchaseUpdateArgs>(args: SelectSubset<T, PlanPurchaseUpdateArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanPurchases.
     * @param {PlanPurchaseDeleteManyArgs} args - Arguments to filter PlanPurchases to delete.
     * @example
     * // Delete a few PlanPurchases
     * const { count } = await prisma.planPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanPurchaseDeleteManyArgs>(args?: SelectSubset<T, PlanPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanPurchases
     * const planPurchase = await prisma.planPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanPurchaseUpdateManyArgs>(args: SelectSubset<T, PlanPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanPurchase.
     * @param {PlanPurchaseUpsertArgs} args - Arguments to update or create a PlanPurchase.
     * @example
     * // Update or create a PlanPurchase
     * const planPurchase = await prisma.planPurchase.upsert({
     *   create: {
     *     // ... data to create a PlanPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanPurchase we want to update
     *   }
     * })
     */
    upsert<T extends PlanPurchaseUpsertArgs>(args: SelectSubset<T, PlanPurchaseUpsertArgs<ExtArgs>>): Prisma__PlanPurchaseClient<$Result.GetResult<Prisma.$PlanPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanPurchases that matches the filter.
     * @param {PlanPurchaseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const planPurchase = await prisma.planPurchase.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PlanPurchaseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PlanPurchase.
     * @param {PlanPurchaseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const planPurchase = await prisma.planPurchase.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlanPurchaseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PlanPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseCountArgs} args - Arguments to filter PlanPurchases to count.
     * @example
     * // Count the number of PlanPurchases
     * const count = await prisma.planPurchase.count({
     *   where: {
     *     // ... the filter for the PlanPurchases we want to count
     *   }
     * })
    **/
    count<T extends PlanPurchaseCountArgs>(
      args?: Subset<T, PlanPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanPurchaseAggregateArgs>(args: Subset<T, PlanPurchaseAggregateArgs>): Prisma.PrismaPromise<GetPlanPurchaseAggregateType<T>>

    /**
     * Group by PlanPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PlanPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanPurchase model
   */
  readonly fields: PlanPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends ExamPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamPlanDefaultArgs<ExtArgs>>): Prisma__ExamPlanClient<$Result.GetResult<Prisma.$ExamPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanPurchase model
   */
  interface PlanPurchaseFieldRefs {
    readonly id: FieldRef<"PlanPurchase", 'String'>
    readonly usedMcqs: FieldRef<"PlanPurchase", 'Int'>
    readonly usedExams: FieldRef<"PlanPurchase", 'Int'>
    readonly usedAttempts: FieldRef<"PlanPurchase", 'Int'>
    readonly status: FieldRef<"PlanPurchase", 'String'>
    readonly userId: FieldRef<"PlanPurchase", 'String'>
    readonly planId: FieldRef<"PlanPurchase", 'String'>
    readonly createdAt: FieldRef<"PlanPurchase", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanPurchase findUnique
   */
  export type PlanPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PlanPurchase to fetch.
     */
    where: PlanPurchaseWhereUniqueInput
  }

  /**
   * PlanPurchase findUniqueOrThrow
   */
  export type PlanPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PlanPurchase to fetch.
     */
    where: PlanPurchaseWhereUniqueInput
  }

  /**
   * PlanPurchase findFirst
   */
  export type PlanPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PlanPurchase to fetch.
     */
    where?: PlanPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPurchases to fetch.
     */
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPurchases.
     */
    cursor?: PlanPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPurchases.
     */
    distinct?: PlanPurchaseScalarFieldEnum | PlanPurchaseScalarFieldEnum[]
  }

  /**
   * PlanPurchase findFirstOrThrow
   */
  export type PlanPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PlanPurchase to fetch.
     */
    where?: PlanPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPurchases to fetch.
     */
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanPurchases.
     */
    cursor?: PlanPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanPurchases.
     */
    distinct?: PlanPurchaseScalarFieldEnum | PlanPurchaseScalarFieldEnum[]
  }

  /**
   * PlanPurchase findMany
   */
  export type PlanPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PlanPurchases to fetch.
     */
    where?: PlanPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanPurchases to fetch.
     */
    orderBy?: PlanPurchaseOrderByWithRelationInput | PlanPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanPurchases.
     */
    cursor?: PlanPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanPurchases.
     */
    skip?: number
    distinct?: PlanPurchaseScalarFieldEnum | PlanPurchaseScalarFieldEnum[]
  }

  /**
   * PlanPurchase create
   */
  export type PlanPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanPurchase.
     */
    data: XOR<PlanPurchaseCreateInput, PlanPurchaseUncheckedCreateInput>
  }

  /**
   * PlanPurchase createMany
   */
  export type PlanPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanPurchases.
     */
    data: PlanPurchaseCreateManyInput | PlanPurchaseCreateManyInput[]
  }

  /**
   * PlanPurchase update
   */
  export type PlanPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanPurchase.
     */
    data: XOR<PlanPurchaseUpdateInput, PlanPurchaseUncheckedUpdateInput>
    /**
     * Choose, which PlanPurchase to update.
     */
    where: PlanPurchaseWhereUniqueInput
  }

  /**
   * PlanPurchase updateMany
   */
  export type PlanPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanPurchases.
     */
    data: XOR<PlanPurchaseUpdateManyMutationInput, PlanPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which PlanPurchases to update
     */
    where?: PlanPurchaseWhereInput
    /**
     * Limit how many PlanPurchases to update.
     */
    limit?: number
  }

  /**
   * PlanPurchase upsert
   */
  export type PlanPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanPurchase to update in case it exists.
     */
    where: PlanPurchaseWhereUniqueInput
    /**
     * In case the PlanPurchase found by the `where` argument doesn't exist, create a new PlanPurchase with this data.
     */
    create: XOR<PlanPurchaseCreateInput, PlanPurchaseUncheckedCreateInput>
    /**
     * In case the PlanPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanPurchaseUpdateInput, PlanPurchaseUncheckedUpdateInput>
  }

  /**
   * PlanPurchase delete
   */
  export type PlanPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
    /**
     * Filter which PlanPurchase to delete.
     */
    where: PlanPurchaseWhereUniqueInput
  }

  /**
   * PlanPurchase deleteMany
   */
  export type PlanPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanPurchases to delete
     */
    where?: PlanPurchaseWhereInput
    /**
     * Limit how many PlanPurchases to delete.
     */
    limit?: number
  }

  /**
   * PlanPurchase findRaw
   */
  export type PlanPurchaseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlanPurchase aggregateRaw
   */
  export type PlanPurchaseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlanPurchase without action
   */
  export type PlanPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanPurchase
     */
    select?: PlanPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanPurchase
     */
    omit?: PlanPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Refer
   */

  export type AggregateRefer = {
    _count: ReferCountAggregateOutputType | null
    _min: ReferMinAggregateOutputType | null
    _max: ReferMaxAggregateOutputType | null
  }

  export type ReferMinAggregateOutputType = {
    id: string | null
    hasPurchased: boolean | null
    refererId: string | null
    refereeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferMaxAggregateOutputType = {
    id: string | null
    hasPurchased: boolean | null
    refererId: string | null
    refereeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferCountAggregateOutputType = {
    id: number
    hasPurchased: number
    refererId: number
    refereeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferMinAggregateInputType = {
    id?: true
    hasPurchased?: true
    refererId?: true
    refereeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferMaxAggregateInputType = {
    id?: true
    hasPurchased?: true
    refererId?: true
    refereeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferCountAggregateInputType = {
    id?: true
    hasPurchased?: true
    refererId?: true
    refereeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refer to aggregate.
     */
    where?: ReferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refers to fetch.
     */
    orderBy?: ReferOrderByWithRelationInput | ReferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refers
    **/
    _count?: true | ReferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferMaxAggregateInputType
  }

  export type GetReferAggregateType<T extends ReferAggregateArgs> = {
        [P in keyof T & keyof AggregateRefer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefer[P]>
      : GetScalarType<T[P], AggregateRefer[P]>
  }




  export type ReferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferWhereInput
    orderBy?: ReferOrderByWithAggregationInput | ReferOrderByWithAggregationInput[]
    by: ReferScalarFieldEnum[] | ReferScalarFieldEnum
    having?: ReferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferCountAggregateInputType | true
    _min?: ReferMinAggregateInputType
    _max?: ReferMaxAggregateInputType
  }

  export type ReferGroupByOutputType = {
    id: string
    hasPurchased: boolean
    refererId: string
    refereeId: string
    createdAt: Date
    updatedAt: Date
    _count: ReferCountAggregateOutputType | null
    _min: ReferMinAggregateOutputType | null
    _max: ReferMaxAggregateOutputType | null
  }

  type GetReferGroupByPayload<T extends ReferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferGroupByOutputType[P]>
            : GetScalarType<T[P], ReferGroupByOutputType[P]>
        }
      >
    >


  export type ReferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hasPurchased?: boolean
    refererId?: boolean
    refereeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refer"]>



  export type ReferSelectScalar = {
    id?: boolean
    hasPurchased?: boolean
    refererId?: boolean
    refereeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hasPurchased" | "refererId" | "refereeId" | "createdAt" | "updatedAt", ExtArgs["result"]["refer"]>
  export type ReferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refer"
    objects: {
      referer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hasPurchased: boolean
      refererId: string
      refereeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refer"]>
    composites: {}
  }

  type ReferGetPayload<S extends boolean | null | undefined | ReferDefaultArgs> = $Result.GetResult<Prisma.$ReferPayload, S>

  type ReferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferCountAggregateInputType | true
    }

  export interface ReferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refer'], meta: { name: 'Refer' } }
    /**
     * Find zero or one Refer that matches the filter.
     * @param {ReferFindUniqueArgs} args - Arguments to find a Refer
     * @example
     * // Get one Refer
     * const refer = await prisma.refer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferFindUniqueArgs>(args: SelectSubset<T, ReferFindUniqueArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferFindUniqueOrThrowArgs} args - Arguments to find a Refer
     * @example
     * // Get one Refer
     * const refer = await prisma.refer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferFindFirstArgs} args - Arguments to find a Refer
     * @example
     * // Get one Refer
     * const refer = await prisma.refer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferFindFirstArgs>(args?: SelectSubset<T, ReferFindFirstArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferFindFirstOrThrowArgs} args - Arguments to find a Refer
     * @example
     * // Get one Refer
     * const refer = await prisma.refer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refers
     * const refers = await prisma.refer.findMany()
     * 
     * // Get first 10 Refers
     * const refers = await prisma.refer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referWithIdOnly = await prisma.refer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferFindManyArgs>(args?: SelectSubset<T, ReferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refer.
     * @param {ReferCreateArgs} args - Arguments to create a Refer.
     * @example
     * // Create one Refer
     * const Refer = await prisma.refer.create({
     *   data: {
     *     // ... data to create a Refer
     *   }
     * })
     * 
     */
    create<T extends ReferCreateArgs>(args: SelectSubset<T, ReferCreateArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refers.
     * @param {ReferCreateManyArgs} args - Arguments to create many Refers.
     * @example
     * // Create many Refers
     * const refer = await prisma.refer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferCreateManyArgs>(args?: SelectSubset<T, ReferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refer.
     * @param {ReferDeleteArgs} args - Arguments to delete one Refer.
     * @example
     * // Delete one Refer
     * const Refer = await prisma.refer.delete({
     *   where: {
     *     // ... filter to delete one Refer
     *   }
     * })
     * 
     */
    delete<T extends ReferDeleteArgs>(args: SelectSubset<T, ReferDeleteArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refer.
     * @param {ReferUpdateArgs} args - Arguments to update one Refer.
     * @example
     * // Update one Refer
     * const refer = await prisma.refer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferUpdateArgs>(args: SelectSubset<T, ReferUpdateArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refers.
     * @param {ReferDeleteManyArgs} args - Arguments to filter Refers to delete.
     * @example
     * // Delete a few Refers
     * const { count } = await prisma.refer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferDeleteManyArgs>(args?: SelectSubset<T, ReferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refers
     * const refer = await prisma.refer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferUpdateManyArgs>(args: SelectSubset<T, ReferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refer.
     * @param {ReferUpsertArgs} args - Arguments to update or create a Refer.
     * @example
     * // Update or create a Refer
     * const refer = await prisma.refer.upsert({
     *   create: {
     *     // ... data to create a Refer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refer we want to update
     *   }
     * })
     */
    upsert<T extends ReferUpsertArgs>(args: SelectSubset<T, ReferUpsertArgs<ExtArgs>>): Prisma__ReferClient<$Result.GetResult<Prisma.$ReferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refers that matches the filter.
     * @param {ReferFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const refer = await prisma.refer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ReferFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Refer.
     * @param {ReferAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const refer = await prisma.refer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReferAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Refers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferCountArgs} args - Arguments to filter Refers to count.
     * @example
     * // Count the number of Refers
     * const count = await prisma.refer.count({
     *   where: {
     *     // ... the filter for the Refers we want to count
     *   }
     * })
    **/
    count<T extends ReferCountArgs>(
      args?: Subset<T, ReferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferAggregateArgs>(args: Subset<T, ReferAggregateArgs>): Prisma.PrismaPromise<GetReferAggregateType<T>>

    /**
     * Group by Refer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferGroupByArgs['orderBy'] }
        : { orderBy?: ReferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refer model
   */
  readonly fields: ReferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refer model
   */
  interface ReferFieldRefs {
    readonly id: FieldRef<"Refer", 'String'>
    readonly hasPurchased: FieldRef<"Refer", 'Boolean'>
    readonly refererId: FieldRef<"Refer", 'String'>
    readonly refereeId: FieldRef<"Refer", 'String'>
    readonly createdAt: FieldRef<"Refer", 'DateTime'>
    readonly updatedAt: FieldRef<"Refer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refer findUnique
   */
  export type ReferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter, which Refer to fetch.
     */
    where: ReferWhereUniqueInput
  }

  /**
   * Refer findUniqueOrThrow
   */
  export type ReferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter, which Refer to fetch.
     */
    where: ReferWhereUniqueInput
  }

  /**
   * Refer findFirst
   */
  export type ReferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter, which Refer to fetch.
     */
    where?: ReferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refers to fetch.
     */
    orderBy?: ReferOrderByWithRelationInput | ReferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refers.
     */
    cursor?: ReferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refers.
     */
    distinct?: ReferScalarFieldEnum | ReferScalarFieldEnum[]
  }

  /**
   * Refer findFirstOrThrow
   */
  export type ReferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter, which Refer to fetch.
     */
    where?: ReferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refers to fetch.
     */
    orderBy?: ReferOrderByWithRelationInput | ReferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refers.
     */
    cursor?: ReferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refers.
     */
    distinct?: ReferScalarFieldEnum | ReferScalarFieldEnum[]
  }

  /**
   * Refer findMany
   */
  export type ReferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter, which Refers to fetch.
     */
    where?: ReferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refers to fetch.
     */
    orderBy?: ReferOrderByWithRelationInput | ReferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refers.
     */
    cursor?: ReferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refers.
     */
    skip?: number
    distinct?: ReferScalarFieldEnum | ReferScalarFieldEnum[]
  }

  /**
   * Refer create
   */
  export type ReferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * The data needed to create a Refer.
     */
    data: XOR<ReferCreateInput, ReferUncheckedCreateInput>
  }

  /**
   * Refer createMany
   */
  export type ReferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refers.
     */
    data: ReferCreateManyInput | ReferCreateManyInput[]
  }

  /**
   * Refer update
   */
  export type ReferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * The data needed to update a Refer.
     */
    data: XOR<ReferUpdateInput, ReferUncheckedUpdateInput>
    /**
     * Choose, which Refer to update.
     */
    where: ReferWhereUniqueInput
  }

  /**
   * Refer updateMany
   */
  export type ReferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refers.
     */
    data: XOR<ReferUpdateManyMutationInput, ReferUncheckedUpdateManyInput>
    /**
     * Filter which Refers to update
     */
    where?: ReferWhereInput
    /**
     * Limit how many Refers to update.
     */
    limit?: number
  }

  /**
   * Refer upsert
   */
  export type ReferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * The filter to search for the Refer to update in case it exists.
     */
    where: ReferWhereUniqueInput
    /**
     * In case the Refer found by the `where` argument doesn't exist, create a new Refer with this data.
     */
    create: XOR<ReferCreateInput, ReferUncheckedCreateInput>
    /**
     * In case the Refer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferUpdateInput, ReferUncheckedUpdateInput>
  }

  /**
   * Refer delete
   */
  export type ReferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
    /**
     * Filter which Refer to delete.
     */
    where: ReferWhereUniqueInput
  }

  /**
   * Refer deleteMany
   */
  export type ReferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refers to delete
     */
    where?: ReferWhereInput
    /**
     * Limit how many Refers to delete.
     */
    limit?: number
  }

  /**
   * Refer findRaw
   */
  export type ReferFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Refer aggregateRaw
   */
  export type ReferAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Refer without action
   */
  export type ReferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refer
     */
    select?: ReferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refer
     */
    omit?: ReferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    isFeatured: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    isFeatured: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    isFeatured?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    isFeatured: boolean
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>



  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    isFeatured?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "isFeatured" | "createdAt" | "updatedAt", ExtArgs["result"]["announcement"]>

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      isFeatured: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * @param {AnnouncementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const announcement = await prisma.announcement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AnnouncementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Announcement.
     * @param {AnnouncementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const announcement = await prisma.announcement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AnnouncementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly isFeatured: FieldRef<"Announcement", 'Boolean'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement findRaw
   */
  export type AnnouncementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Announcement aggregateRaw
   */
  export type AnnouncementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
  }


  /**
   * Model Recommendation
   */

  export type AggregateRecommendation = {
    _count: RecommendationCountAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  export type RecommendationMinAggregateOutputType = {
    id: string | null
    title: string | null
    reason: string | null
    examId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    reason: string | null
    examId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendationCountAggregateOutputType = {
    id: number
    title: number
    reason: number
    examId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecommendationMinAggregateInputType = {
    id?: true
    title?: true
    reason?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendationMaxAggregateInputType = {
    id?: true
    title?: true
    reason?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendationCountAggregateInputType = {
    id?: true
    title?: true
    reason?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendation to aggregate.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recommendations
    **/
    _count?: true | RecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendationMaxAggregateInputType
  }

  export type GetRecommendationAggregateType<T extends RecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendation[P]>
      : GetScalarType<T[P], AggregateRecommendation[P]>
  }




  export type RecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithAggregationInput | RecommendationOrderByWithAggregationInput[]
    by: RecommendationScalarFieldEnum[] | RecommendationScalarFieldEnum
    having?: RecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendationCountAggregateInputType | true
    _min?: RecommendationMinAggregateInputType
    _max?: RecommendationMaxAggregateInputType
  }

  export type RecommendationGroupByOutputType = {
    id: string
    title: string
    reason: string
    examId: string
    createdAt: Date
    updatedAt: Date
    _count: RecommendationCountAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  type GetRecommendationGroupByPayload<T extends RecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
        }
      >
    >


  export type RecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    reason?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>



  export type RecommendationSelectScalar = {
    id?: boolean
    title?: boolean
    reason?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "reason" | "examId" | "createdAt" | "updatedAt", ExtArgs["result"]["recommendation"]>
  export type RecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }

  export type $RecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recommendation"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      reason: string
      examId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recommendation"]>
    composites: {}
  }

  type RecommendationGetPayload<S extends boolean | null | undefined | RecommendationDefaultArgs> = $Result.GetResult<Prisma.$RecommendationPayload, S>

  type RecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecommendationCountAggregateInputType | true
    }

  export interface RecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recommendation'], meta: { name: 'Recommendation' } }
    /**
     * Find zero or one Recommendation that matches the filter.
     * @param {RecommendationFindUniqueArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendationFindUniqueArgs>(args: SelectSubset<T, RecommendationFindUniqueArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecommendationFindUniqueOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendationFindFirstArgs>(args?: SelectSubset<T, RecommendationFindFirstArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recommendations
     * const recommendations = await prisma.recommendation.findMany()
     * 
     * // Get first 10 Recommendations
     * const recommendations = await prisma.recommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendationFindManyArgs>(args?: SelectSubset<T, RecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recommendation.
     * @param {RecommendationCreateArgs} args - Arguments to create a Recommendation.
     * @example
     * // Create one Recommendation
     * const Recommendation = await prisma.recommendation.create({
     *   data: {
     *     // ... data to create a Recommendation
     *   }
     * })
     * 
     */
    create<T extends RecommendationCreateArgs>(args: SelectSubset<T, RecommendationCreateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recommendations.
     * @param {RecommendationCreateManyArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendationCreateManyArgs>(args?: SelectSubset<T, RecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recommendation.
     * @param {RecommendationDeleteArgs} args - Arguments to delete one Recommendation.
     * @example
     * // Delete one Recommendation
     * const Recommendation = await prisma.recommendation.delete({
     *   where: {
     *     // ... filter to delete one Recommendation
     *   }
     * })
     * 
     */
    delete<T extends RecommendationDeleteArgs>(args: SelectSubset<T, RecommendationDeleteArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recommendation.
     * @param {RecommendationUpdateArgs} args - Arguments to update one Recommendation.
     * @example
     * // Update one Recommendation
     * const recommendation = await prisma.recommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendationUpdateArgs>(args: SelectSubset<T, RecommendationUpdateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recommendations.
     * @param {RecommendationDeleteManyArgs} args - Arguments to filter Recommendations to delete.
     * @example
     * // Delete a few Recommendations
     * const { count } = await prisma.recommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendationDeleteManyArgs>(args?: SelectSubset<T, RecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recommendations
     * const recommendation = await prisma.recommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendationUpdateManyArgs>(args: SelectSubset<T, RecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recommendation.
     * @param {RecommendationUpsertArgs} args - Arguments to update or create a Recommendation.
     * @example
     * // Update or create a Recommendation
     * const recommendation = await prisma.recommendation.upsert({
     *   create: {
     *     // ... data to create a Recommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recommendation we want to update
     *   }
     * })
     */
    upsert<T extends RecommendationUpsertArgs>(args: SelectSubset<T, RecommendationUpsertArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recommendations that matches the filter.
     * @param {RecommendationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const recommendation = await prisma.recommendation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RecommendationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Recommendation.
     * @param {RecommendationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const recommendation = await prisma.recommendation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RecommendationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationCountArgs} args - Arguments to filter Recommendations to count.
     * @example
     * // Count the number of Recommendations
     * const count = await prisma.recommendation.count({
     *   where: {
     *     // ... the filter for the Recommendations we want to count
     *   }
     * })
    **/
    count<T extends RecommendationCountArgs>(
      args?: Subset<T, RecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendationAggregateArgs>(args: Subset<T, RecommendationAggregateArgs>): Prisma.PrismaPromise<GetRecommendationAggregateType<T>>

    /**
     * Group by Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendationGroupByArgs['orderBy'] }
        : { orderBy?: RecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recommendation model
   */
  readonly fields: RecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recommendation model
   */
  interface RecommendationFieldRefs {
    readonly id: FieldRef<"Recommendation", 'String'>
    readonly title: FieldRef<"Recommendation", 'String'>
    readonly reason: FieldRef<"Recommendation", 'String'>
    readonly examId: FieldRef<"Recommendation", 'String'>
    readonly createdAt: FieldRef<"Recommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"Recommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recommendation findUnique
   */
  export type RecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findUniqueOrThrow
   */
  export type RecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findFirst
   */
  export type RecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findFirstOrThrow
   */
  export type RecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findMany
   */
  export type RecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendations to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation create
   */
  export type RecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a Recommendation.
     */
    data: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
  }

  /**
   * Recommendation createMany
   */
  export type RecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
  }

  /**
   * Recommendation update
   */
  export type RecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a Recommendation.
     */
    data: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
    /**
     * Choose, which Recommendation to update.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation updateMany
   */
  export type RecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recommendations.
     */
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyInput>
    /**
     * Filter which Recommendations to update
     */
    where?: RecommendationWhereInput
    /**
     * Limit how many Recommendations to update.
     */
    limit?: number
  }

  /**
   * Recommendation upsert
   */
  export type RecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the Recommendation to update in case it exists.
     */
    where: RecommendationWhereUniqueInput
    /**
     * In case the Recommendation found by the `where` argument doesn't exist, create a new Recommendation with this data.
     */
    create: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
    /**
     * In case the Recommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
  }

  /**
   * Recommendation delete
   */
  export type RecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter which Recommendation to delete.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation deleteMany
   */
  export type RecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendations to delete
     */
    where?: RecommendationWhereInput
    /**
     * Limit how many Recommendations to delete.
     */
    limit?: number
  }

  /**
   * Recommendation findRaw
   */
  export type RecommendationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Recommendation aggregateRaw
   */
  export type RecommendationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Recommendation without action
   */
  export type RecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    status: 'status',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    expiresAt: 'expiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const ClassNameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    position: 'position',
    subjectIds: 'subjectIds',
    chapterIds: 'chapterIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassNameScalarFieldEnum = (typeof ClassNameScalarFieldEnum)[keyof typeof ClassNameScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    group: 'group',
    classNameIds: 'classNameIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    subjectId: 'subjectId',
    examIds: 'examIds',
    classNameIds: 'classNameIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const ChapterContextScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    authorSummary: 'authorSummary',
    content: 'content',
    meaning: 'meaning',
    summary: 'summary',
    chapterId: 'chapterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChapterContextScalarFieldEnum = (typeof ChapterContextScalarFieldEnum)[keyof typeof ChapterContextScalarFieldEnum]


  export const McqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    options: 'options',
    statements: 'statements',
    answer: 'answer',
    type: 'type',
    reference: 'reference',
    explanation: 'explanation',
    isMath: 'isMath',
    session: 'session',
    source: 'source',
    questionUrl: 'questionUrl',
    contextUrl: 'contextUrl',
    context: 'context',
    subjectId: 'subjectId',
    chapterId: 'chapterId',
    examIds: 'examIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type McqScalarFieldEnum = (typeof McqScalarFieldEnum)[keyof typeof McqScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    questionCount: 'questionCount',
    duration: 'duration',
    status: 'status',
    classNameId: 'classNameId',
    subjectId: 'subjectId',
    chapterIds: 'chapterIds',
    questionIds: 'questionIds',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const McqAttemptScalarFieldEnum: {
    id: 'id',
    answers: 'answers',
    total: 'total',
    score: 'score',
    streak: 'streak',
    longestStreak: 'longestStreak',
    wrongAnswer: 'wrongAnswer',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    examId: 'examId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type McqAttemptScalarFieldEnum = (typeof McqAttemptScalarFieldEnum)[keyof typeof McqAttemptScalarFieldEnum]


  export const ExamFeedbackScalarFieldEnum: {
    id: 'id',
    mcqAttemptId: 'mcqAttemptId',
    userId: 'userId',
    overallSummary: 'overallSummary',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    recommendations: 'recommendations',
    detailedAnalysis: 'detailedAnalysis',
    userRating: 'userRating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamFeedbackScalarFieldEnum = (typeof ExamFeedbackScalarFieldEnum)[keyof typeof ExamFeedbackScalarFieldEnum]


  export const CreditPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    credit: 'credit',
    price: 'price',
    discount: 'discount',
    save: 'save',
    bonus: 'bonus',
    status: 'status',
    isPopular: 'isPopular',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditPlanScalarFieldEnum = (typeof CreditPlanScalarFieldEnum)[keyof typeof CreditPlanScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    amount: 'amount',
    type: 'type',
    method: 'method',
    status: 'status',
    userId: 'userId',
    creditPlanId: 'creditPlanId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ExamPlanScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    credit: 'credit',
    mcqs: 'mcqs',
    exams: 'exams',
    attempts: 'attempts',
    features: 'features',
    aiFeedbackFeatures: 'aiFeedbackFeatures',
    enableDownloadReport: 'enableDownloadReport',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamPlanScalarFieldEnum = (typeof ExamPlanScalarFieldEnum)[keyof typeof ExamPlanScalarFieldEnum]


  export const PlanPurchaseScalarFieldEnum: {
    id: 'id',
    usedMcqs: 'usedMcqs',
    usedExams: 'usedExams',
    usedAttempts: 'usedAttempts',
    status: 'status',
    userId: 'userId',
    planId: 'planId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanPurchaseScalarFieldEnum = (typeof PlanPurchaseScalarFieldEnum)[keyof typeof PlanPurchaseScalarFieldEnum]


  export const ReferScalarFieldEnum: {
    id: 'id',
    hasPurchased: 'hasPurchased',
    refererId: 'refererId',
    refereeId: 'refereeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferScalarFieldEnum = (typeof ReferScalarFieldEnum)[keyof typeof ReferScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    isFeatured: 'isFeatured',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const RecommendationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    reason: 'reason',
    examId: 'examId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecommendationScalarFieldEnum = (typeof RecommendationScalarFieldEnum)[keyof typeof RecommendationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredToMe?: XOR<ReferNullableScalarRelationFilter, ReferWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    exams?: ExamListRelationFilter
    attempts?: McqAttemptListRelationFilter
    feedbacks?: ExamFeedbackListRelationFilter
    transactions?: TransactionListRelationFilter
    purchases?: PlanPurchaseListRelationFilter
    referredByMe?: ReferListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referredToMe?: ReferOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    attempts?: McqAttemptOrderByRelationAggregateInput
    feedbacks?: ExamFeedbackOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    purchases?: PlanPurchaseOrderByRelationAggregateInput
    referredByMe?: ReferOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredToMe?: XOR<ReferNullableScalarRelationFilter, ReferWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    exams?: ExamListRelationFilter
    attempts?: McqAttemptListRelationFilter
    feedbacks?: ExamFeedbackListRelationFilter
    transactions?: TransactionListRelationFilter
    purchases?: PlanPurchaseListRelationFilter
    referredByMe?: ReferListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_value?: VerificationIdentifierValueCompoundUniqueInput
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "identifier_value">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type ClassNameWhereInput = {
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    level?: StringFilter<"ClassName"> | string
    position?: IntFilter<"ClassName"> | number
    subjectIds?: StringNullableListFilter<"ClassName">
    chapterIds?: StringNullableListFilter<"ClassName">
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    subjects?: SubjectListRelationFilter
    chapters?: ChapterListRelationFilter
    exams?: ExamListRelationFilter
  }

  export type ClassNameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    position?: SortOrder
    subjectIds?: SortOrder
    chapterIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subjects?: SubjectOrderByRelationAggregateInput
    chapters?: ChapterOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
  }

  export type ClassNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    level?: StringFilter<"ClassName"> | string
    position?: IntFilter<"ClassName"> | number
    subjectIds?: StringNullableListFilter<"ClassName">
    chapterIds?: StringNullableListFilter<"ClassName">
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    subjects?: SubjectListRelationFilter
    chapters?: ChapterListRelationFilter
    exams?: ExamListRelationFilter
  }, "id" | "name">

  export type ClassNameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    position?: SortOrder
    subjectIds?: SortOrder
    chapterIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassNameCountOrderByAggregateInput
    _avg?: ClassNameAvgOrderByAggregateInput
    _max?: ClassNameMaxOrderByAggregateInput
    _min?: ClassNameMinOrderByAggregateInput
    _sum?: ClassNameSumOrderByAggregateInput
  }

  export type ClassNameScalarWhereWithAggregatesInput = {
    AND?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    OR?: ClassNameScalarWhereWithAggregatesInput[]
    NOT?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassName"> | string
    name?: StringWithAggregatesFilter<"ClassName"> | string
    level?: StringWithAggregatesFilter<"ClassName"> | string
    position?: IntWithAggregatesFilter<"ClassName"> | number
    subjectIds?: StringNullableListFilter<"ClassName">
    chapterIds?: StringNullableListFilter<"ClassName">
    createdAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    group?: StringNullableFilter<"Subject"> | string | null
    classNameIds?: StringNullableListFilter<"Subject">
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    classNames?: ClassNameListRelationFilter
    chapters?: ChapterListRelationFilter
    mcqs?: McqListRelationFilter
    exams?: ExamListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    group?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classNames?: ClassNameOrderByRelationAggregateInput
    chapters?: ChapterOrderByRelationAggregateInput
    mcqs?: McqOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    group?: StringNullableFilter<"Subject"> | string | null
    classNameIds?: StringNullableListFilter<"Subject">
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    classNames?: ClassNameListRelationFilter
    chapters?: ChapterListRelationFilter
    mcqs?: McqListRelationFilter
    exams?: ExamListRelationFilter
  }, "id">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    group?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    group?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    classNameIds?: StringNullableListFilter<"Subject">
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    name?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    subjectId?: StringFilter<"Chapter"> | string
    examIds?: StringNullableListFilter<"Chapter">
    classNameIds?: StringNullableListFilter<"Chapter">
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    exams?: ExamListRelationFilter
    classNames?: ClassNameListRelationFilter
    context?: XOR<ChapterContextNullableScalarRelationFilter, ChapterContextWhereInput> | null
    mcqs?: McqListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    subjectId?: SortOrder
    examIds?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
    exams?: ExamOrderByRelationAggregateInput
    classNames?: ClassNameOrderByRelationAggregateInput
    context?: ChapterContextOrderByWithRelationInput
    mcqs?: McqOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    name?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    subjectId?: StringFilter<"Chapter"> | string
    examIds?: StringNullableListFilter<"Chapter">
    classNameIds?: StringNullableListFilter<"Chapter">
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    exams?: ExamListRelationFilter
    classNames?: ClassNameListRelationFilter
    context?: XOR<ChapterContextNullableScalarRelationFilter, ChapterContextWhereInput> | null
    mcqs?: McqListRelationFilter
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    subjectId?: SortOrder
    examIds?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    name?: StringWithAggregatesFilter<"Chapter"> | string
    position?: IntWithAggregatesFilter<"Chapter"> | number
    subjectId?: StringWithAggregatesFilter<"Chapter"> | string
    examIds?: StringNullableListFilter<"Chapter">
    classNameIds?: StringNullableListFilter<"Chapter">
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type ChapterContextWhereInput = {
    AND?: ChapterContextWhereInput | ChapterContextWhereInput[]
    OR?: ChapterContextWhereInput[]
    NOT?: ChapterContextWhereInput | ChapterContextWhereInput[]
    id?: StringFilter<"ChapterContext"> | string
    title?: StringFilter<"ChapterContext"> | string
    author?: StringNullableFilter<"ChapterContext"> | string | null
    authorSummary?: StringNullableFilter<"ChapterContext"> | string | null
    content?: StringFilter<"ChapterContext"> | string
    meaning?: StringNullableFilter<"ChapterContext"> | string | null
    summary?: StringNullableFilter<"ChapterContext"> | string | null
    chapterId?: StringFilter<"ChapterContext"> | string
    createdAt?: DateTimeFilter<"ChapterContext"> | Date | string
    updatedAt?: DateTimeFilter<"ChapterContext"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type ChapterContextOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    authorSummary?: SortOrder
    content?: SortOrder
    meaning?: SortOrder
    summary?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
  }

  export type ChapterContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chapterId?: string
    AND?: ChapterContextWhereInput | ChapterContextWhereInput[]
    OR?: ChapterContextWhereInput[]
    NOT?: ChapterContextWhereInput | ChapterContextWhereInput[]
    title?: StringFilter<"ChapterContext"> | string
    author?: StringNullableFilter<"ChapterContext"> | string | null
    authorSummary?: StringNullableFilter<"ChapterContext"> | string | null
    content?: StringFilter<"ChapterContext"> | string
    meaning?: StringNullableFilter<"ChapterContext"> | string | null
    summary?: StringNullableFilter<"ChapterContext"> | string | null
    createdAt?: DateTimeFilter<"ChapterContext"> | Date | string
    updatedAt?: DateTimeFilter<"ChapterContext"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id" | "chapterId">

  export type ChapterContextOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    authorSummary?: SortOrder
    content?: SortOrder
    meaning?: SortOrder
    summary?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChapterContextCountOrderByAggregateInput
    _max?: ChapterContextMaxOrderByAggregateInput
    _min?: ChapterContextMinOrderByAggregateInput
  }

  export type ChapterContextScalarWhereWithAggregatesInput = {
    AND?: ChapterContextScalarWhereWithAggregatesInput | ChapterContextScalarWhereWithAggregatesInput[]
    OR?: ChapterContextScalarWhereWithAggregatesInput[]
    NOT?: ChapterContextScalarWhereWithAggregatesInput | ChapterContextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChapterContext"> | string
    title?: StringWithAggregatesFilter<"ChapterContext"> | string
    author?: StringNullableWithAggregatesFilter<"ChapterContext"> | string | null
    authorSummary?: StringNullableWithAggregatesFilter<"ChapterContext"> | string | null
    content?: StringWithAggregatesFilter<"ChapterContext"> | string
    meaning?: StringNullableWithAggregatesFilter<"ChapterContext"> | string | null
    summary?: StringNullableWithAggregatesFilter<"ChapterContext"> | string | null
    chapterId?: StringWithAggregatesFilter<"ChapterContext"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChapterContext"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChapterContext"> | Date | string
  }

  export type McqWhereInput = {
    AND?: McqWhereInput | McqWhereInput[]
    OR?: McqWhereInput[]
    NOT?: McqWhereInput | McqWhereInput[]
    id?: StringFilter<"Mcq"> | string
    question?: StringFilter<"Mcq"> | string
    options?: StringNullableListFilter<"Mcq">
    statements?: StringNullableListFilter<"Mcq">
    answer?: StringFilter<"Mcq"> | string
    type?: StringFilter<"Mcq"> | string
    reference?: StringNullableFilter<"Mcq"> | string | null
    explanation?: StringNullableFilter<"Mcq"> | string | null
    isMath?: BoolFilter<"Mcq"> | boolean
    session?: IntFilter<"Mcq"> | number
    source?: StringNullableFilter<"Mcq"> | string | null
    questionUrl?: StringNullableFilter<"Mcq"> | string | null
    contextUrl?: StringNullableFilter<"Mcq"> | string | null
    context?: StringNullableFilter<"Mcq"> | string | null
    subjectId?: StringFilter<"Mcq"> | string
    chapterId?: StringFilter<"Mcq"> | string
    examIds?: StringNullableListFilter<"Mcq">
    createdAt?: DateTimeFilter<"Mcq"> | Date | string
    updatedAt?: DateTimeFilter<"Mcq"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    exams?: ExamListRelationFilter
  }

  export type McqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    statements?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    explanation?: SortOrder
    isMath?: SortOrder
    session?: SortOrder
    source?: SortOrder
    questionUrl?: SortOrder
    contextUrl?: SortOrder
    context?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    examIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    exams?: ExamOrderByRelationAggregateInput
  }

  export type McqWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: McqWhereInput | McqWhereInput[]
    OR?: McqWhereInput[]
    NOT?: McqWhereInput | McqWhereInput[]
    question?: StringFilter<"Mcq"> | string
    options?: StringNullableListFilter<"Mcq">
    statements?: StringNullableListFilter<"Mcq">
    answer?: StringFilter<"Mcq"> | string
    type?: StringFilter<"Mcq"> | string
    reference?: StringNullableFilter<"Mcq"> | string | null
    explanation?: StringNullableFilter<"Mcq"> | string | null
    isMath?: BoolFilter<"Mcq"> | boolean
    session?: IntFilter<"Mcq"> | number
    source?: StringNullableFilter<"Mcq"> | string | null
    questionUrl?: StringNullableFilter<"Mcq"> | string | null
    contextUrl?: StringNullableFilter<"Mcq"> | string | null
    context?: StringNullableFilter<"Mcq"> | string | null
    subjectId?: StringFilter<"Mcq"> | string
    chapterId?: StringFilter<"Mcq"> | string
    examIds?: StringNullableListFilter<"Mcq">
    createdAt?: DateTimeFilter<"Mcq"> | Date | string
    updatedAt?: DateTimeFilter<"Mcq"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    exams?: ExamListRelationFilter
  }, "id">

  export type McqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    statements?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    explanation?: SortOrder
    isMath?: SortOrder
    session?: SortOrder
    source?: SortOrder
    questionUrl?: SortOrder
    contextUrl?: SortOrder
    context?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    examIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: McqCountOrderByAggregateInput
    _avg?: McqAvgOrderByAggregateInput
    _max?: McqMaxOrderByAggregateInput
    _min?: McqMinOrderByAggregateInput
    _sum?: McqSumOrderByAggregateInput
  }

  export type McqScalarWhereWithAggregatesInput = {
    AND?: McqScalarWhereWithAggregatesInput | McqScalarWhereWithAggregatesInput[]
    OR?: McqScalarWhereWithAggregatesInput[]
    NOT?: McqScalarWhereWithAggregatesInput | McqScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mcq"> | string
    question?: StringWithAggregatesFilter<"Mcq"> | string
    options?: StringNullableListFilter<"Mcq">
    statements?: StringNullableListFilter<"Mcq">
    answer?: StringWithAggregatesFilter<"Mcq"> | string
    type?: StringWithAggregatesFilter<"Mcq"> | string
    reference?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    explanation?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    isMath?: BoolWithAggregatesFilter<"Mcq"> | boolean
    session?: IntWithAggregatesFilter<"Mcq"> | number
    source?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    questionUrl?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    contextUrl?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    context?: StringNullableWithAggregatesFilter<"Mcq"> | string | null
    subjectId?: StringWithAggregatesFilter<"Mcq"> | string
    chapterId?: StringWithAggregatesFilter<"Mcq"> | string
    examIds?: StringNullableListFilter<"Mcq">
    createdAt?: DateTimeWithAggregatesFilter<"Mcq"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mcq"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    questionCount?: IntFilter<"Exam"> | number
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    classNameId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    chapterIds?: StringNullableListFilter<"Exam">
    questionIds?: StringNullableListFilter<"Exam">
    userId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    className?: XOR<ClassNameScalarRelationFilter, ClassNameWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapters?: ChapterListRelationFilter
    questions?: McqListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attempts?: McqAttemptListRelationFilter
    recommendations?: RecommendationListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    questionCount?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    classNameId?: SortOrder
    subjectId?: SortOrder
    chapterIds?: SortOrder
    questionIds?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    className?: ClassNameOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    questions?: McqOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    attempts?: McqAttemptOrderByRelationAggregateInput
    recommendations?: RecommendationOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    questionCount?: IntFilter<"Exam"> | number
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    classNameId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    chapterIds?: StringNullableListFilter<"Exam">
    questionIds?: StringNullableListFilter<"Exam">
    userId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    className?: XOR<ClassNameScalarRelationFilter, ClassNameWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    chapters?: ChapterListRelationFilter
    questions?: McqListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attempts?: McqAttemptListRelationFilter
    recommendations?: RecommendationListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    questionCount?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    classNameId?: SortOrder
    subjectId?: SortOrder
    chapterIds?: SortOrder
    questionIds?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    type?: StringWithAggregatesFilter<"Exam"> | string
    questionCount?: IntWithAggregatesFilter<"Exam"> | number
    duration?: IntWithAggregatesFilter<"Exam"> | number
    status?: StringWithAggregatesFilter<"Exam"> | string
    classNameId?: StringWithAggregatesFilter<"Exam"> | string
    subjectId?: StringWithAggregatesFilter<"Exam"> | string
    chapterIds?: StringNullableListFilter<"Exam">
    questionIds?: StringNullableListFilter<"Exam">
    userId?: StringWithAggregatesFilter<"Exam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type McqAttemptWhereInput = {
    AND?: McqAttemptWhereInput | McqAttemptWhereInput[]
    OR?: McqAttemptWhereInput[]
    NOT?: McqAttemptWhereInput | McqAttemptWhereInput[]
    id?: StringFilter<"McqAttempt"> | string
    answers?: StringNullableListFilter<"McqAttempt">
    total?: IntFilter<"McqAttempt"> | number
    score?: IntFilter<"McqAttempt"> | number
    streak?: IntFilter<"McqAttempt"> | number
    longestStreak?: IntFilter<"McqAttempt"> | number
    wrongAnswer?: IntFilter<"McqAttempt"> | number
    status?: StringFilter<"McqAttempt"> | string
    startTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    endTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    examId?: StringFilter<"McqAttempt"> | string
    userId?: StringFilter<"McqAttempt"> | string
    createdAt?: DateTimeFilter<"McqAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"McqAttempt"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    feedback?: XOR<ExamFeedbackNullableScalarRelationFilter, ExamFeedbackWhereInput> | null
  }

  export type McqAttemptOrderByWithRelationInput = {
    id?: SortOrder
    answers?: SortOrder
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    feedback?: ExamFeedbackOrderByWithRelationInput
  }

  export type McqAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: McqAttemptWhereInput | McqAttemptWhereInput[]
    OR?: McqAttemptWhereInput[]
    NOT?: McqAttemptWhereInput | McqAttemptWhereInput[]
    answers?: StringNullableListFilter<"McqAttempt">
    total?: IntFilter<"McqAttempt"> | number
    score?: IntFilter<"McqAttempt"> | number
    streak?: IntFilter<"McqAttempt"> | number
    longestStreak?: IntFilter<"McqAttempt"> | number
    wrongAnswer?: IntFilter<"McqAttempt"> | number
    status?: StringFilter<"McqAttempt"> | string
    startTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    endTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    examId?: StringFilter<"McqAttempt"> | string
    userId?: StringFilter<"McqAttempt"> | string
    createdAt?: DateTimeFilter<"McqAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"McqAttempt"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    feedback?: XOR<ExamFeedbackNullableScalarRelationFilter, ExamFeedbackWhereInput> | null
  }, "id">

  export type McqAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    answers?: SortOrder
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: McqAttemptCountOrderByAggregateInput
    _avg?: McqAttemptAvgOrderByAggregateInput
    _max?: McqAttemptMaxOrderByAggregateInput
    _min?: McqAttemptMinOrderByAggregateInput
    _sum?: McqAttemptSumOrderByAggregateInput
  }

  export type McqAttemptScalarWhereWithAggregatesInput = {
    AND?: McqAttemptScalarWhereWithAggregatesInput | McqAttemptScalarWhereWithAggregatesInput[]
    OR?: McqAttemptScalarWhereWithAggregatesInput[]
    NOT?: McqAttemptScalarWhereWithAggregatesInput | McqAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"McqAttempt"> | string
    answers?: StringNullableListFilter<"McqAttempt">
    total?: IntWithAggregatesFilter<"McqAttempt"> | number
    score?: IntWithAggregatesFilter<"McqAttempt"> | number
    streak?: IntWithAggregatesFilter<"McqAttempt"> | number
    longestStreak?: IntWithAggregatesFilter<"McqAttempt"> | number
    wrongAnswer?: IntWithAggregatesFilter<"McqAttempt"> | number
    status?: StringWithAggregatesFilter<"McqAttempt"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"McqAttempt"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"McqAttempt"> | Date | string | null
    examId?: StringWithAggregatesFilter<"McqAttempt"> | string
    userId?: StringWithAggregatesFilter<"McqAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"McqAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"McqAttempt"> | Date | string
  }

  export type ExamFeedbackWhereInput = {
    AND?: ExamFeedbackWhereInput | ExamFeedbackWhereInput[]
    OR?: ExamFeedbackWhereInput[]
    NOT?: ExamFeedbackWhereInput | ExamFeedbackWhereInput[]
    id?: StringFilter<"ExamFeedback"> | string
    mcqAttemptId?: StringFilter<"ExamFeedback"> | string
    userId?: StringFilter<"ExamFeedback"> | string
    overallSummary?: StringFilter<"ExamFeedback"> | string
    strengths?: StringNullableListFilter<"ExamFeedback">
    weaknesses?: StringNullableListFilter<"ExamFeedback">
    recommendations?: StringNullableListFilter<"ExamFeedback">
    detailedAnalysis?: JsonNullableFilter<"ExamFeedback">
    userRating?: IntNullableFilter<"ExamFeedback"> | number | null
    createdAt?: DateTimeFilter<"ExamFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"ExamFeedback"> | Date | string
    mcqAttempt?: XOR<McqAttemptScalarRelationFilter, McqAttemptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExamFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    mcqAttemptId?: SortOrder
    userId?: SortOrder
    overallSummary?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    detailedAnalysis?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mcqAttempt?: McqAttemptOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ExamFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mcqAttemptId?: string
    AND?: ExamFeedbackWhereInput | ExamFeedbackWhereInput[]
    OR?: ExamFeedbackWhereInput[]
    NOT?: ExamFeedbackWhereInput | ExamFeedbackWhereInput[]
    userId?: StringFilter<"ExamFeedback"> | string
    overallSummary?: StringFilter<"ExamFeedback"> | string
    strengths?: StringNullableListFilter<"ExamFeedback">
    weaknesses?: StringNullableListFilter<"ExamFeedback">
    recommendations?: StringNullableListFilter<"ExamFeedback">
    detailedAnalysis?: JsonNullableFilter<"ExamFeedback">
    userRating?: IntNullableFilter<"ExamFeedback"> | number | null
    createdAt?: DateTimeFilter<"ExamFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"ExamFeedback"> | Date | string
    mcqAttempt?: XOR<McqAttemptScalarRelationFilter, McqAttemptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "mcqAttemptId">

  export type ExamFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    mcqAttemptId?: SortOrder
    userId?: SortOrder
    overallSummary?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    detailedAnalysis?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamFeedbackCountOrderByAggregateInput
    _avg?: ExamFeedbackAvgOrderByAggregateInput
    _max?: ExamFeedbackMaxOrderByAggregateInput
    _min?: ExamFeedbackMinOrderByAggregateInput
    _sum?: ExamFeedbackSumOrderByAggregateInput
  }

  export type ExamFeedbackScalarWhereWithAggregatesInput = {
    AND?: ExamFeedbackScalarWhereWithAggregatesInput | ExamFeedbackScalarWhereWithAggregatesInput[]
    OR?: ExamFeedbackScalarWhereWithAggregatesInput[]
    NOT?: ExamFeedbackScalarWhereWithAggregatesInput | ExamFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamFeedback"> | string
    mcqAttemptId?: StringWithAggregatesFilter<"ExamFeedback"> | string
    userId?: StringWithAggregatesFilter<"ExamFeedback"> | string
    overallSummary?: StringWithAggregatesFilter<"ExamFeedback"> | string
    strengths?: StringNullableListFilter<"ExamFeedback">
    weaknesses?: StringNullableListFilter<"ExamFeedback">
    recommendations?: StringNullableListFilter<"ExamFeedback">
    detailedAnalysis?: JsonNullableWithAggregatesFilter<"ExamFeedback">
    userRating?: IntNullableWithAggregatesFilter<"ExamFeedback"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ExamFeedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamFeedback"> | Date | string
  }

  export type CreditPlanWhereInput = {
    AND?: CreditPlanWhereInput | CreditPlanWhereInput[]
    OR?: CreditPlanWhereInput[]
    NOT?: CreditPlanWhereInput | CreditPlanWhereInput[]
    id?: StringFilter<"CreditPlan"> | string
    name?: StringFilter<"CreditPlan"> | string
    credit?: IntFilter<"CreditPlan"> | number
    price?: IntFilter<"CreditPlan"> | number
    discount?: IntFilter<"CreditPlan"> | number
    save?: IntFilter<"CreditPlan"> | number
    bonus?: IntFilter<"CreditPlan"> | number
    status?: StringFilter<"CreditPlan"> | string
    isPopular?: BoolFilter<"CreditPlan"> | boolean
    createdAt?: DateTimeFilter<"CreditPlan"> | Date | string
    updatedAt?: DateTimeFilter<"CreditPlan"> | Date | string
    transactions?: TransactionListRelationFilter
  }

  export type CreditPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
    status?: SortOrder
    isPopular?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type CreditPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditPlanWhereInput | CreditPlanWhereInput[]
    OR?: CreditPlanWhereInput[]
    NOT?: CreditPlanWhereInput | CreditPlanWhereInput[]
    name?: StringFilter<"CreditPlan"> | string
    credit?: IntFilter<"CreditPlan"> | number
    price?: IntFilter<"CreditPlan"> | number
    discount?: IntFilter<"CreditPlan"> | number
    save?: IntFilter<"CreditPlan"> | number
    bonus?: IntFilter<"CreditPlan"> | number
    status?: StringFilter<"CreditPlan"> | string
    isPopular?: BoolFilter<"CreditPlan"> | boolean
    createdAt?: DateTimeFilter<"CreditPlan"> | Date | string
    updatedAt?: DateTimeFilter<"CreditPlan"> | Date | string
    transactions?: TransactionListRelationFilter
  }, "id">

  export type CreditPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
    status?: SortOrder
    isPopular?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreditPlanCountOrderByAggregateInput
    _avg?: CreditPlanAvgOrderByAggregateInput
    _max?: CreditPlanMaxOrderByAggregateInput
    _min?: CreditPlanMinOrderByAggregateInput
    _sum?: CreditPlanSumOrderByAggregateInput
  }

  export type CreditPlanScalarWhereWithAggregatesInput = {
    AND?: CreditPlanScalarWhereWithAggregatesInput | CreditPlanScalarWhereWithAggregatesInput[]
    OR?: CreditPlanScalarWhereWithAggregatesInput[]
    NOT?: CreditPlanScalarWhereWithAggregatesInput | CreditPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditPlan"> | string
    name?: StringWithAggregatesFilter<"CreditPlan"> | string
    credit?: IntWithAggregatesFilter<"CreditPlan"> | number
    price?: IntWithAggregatesFilter<"CreditPlan"> | number
    discount?: IntWithAggregatesFilter<"CreditPlan"> | number
    save?: IntWithAggregatesFilter<"CreditPlan"> | number
    bonus?: IntWithAggregatesFilter<"CreditPlan"> | number
    status?: StringWithAggregatesFilter<"CreditPlan"> | string
    isPopular?: BoolWithAggregatesFilter<"CreditPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CreditPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreditPlan"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    transactionId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    type?: StringFilter<"Transaction"> | string
    method?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    creditPlanId?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditPlan?: XOR<CreditPlanScalarRelationFilter, CreditPlanWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    creditPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    creditPlan?: CreditPlanOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    transactionId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    type?: StringFilter<"Transaction"> | string
    method?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    creditPlanId?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditPlan?: XOR<CreditPlanScalarRelationFilter, CreditPlanWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    creditPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    transactionId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    type?: StringWithAggregatesFilter<"Transaction"> | string
    method?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    creditPlanId?: StringWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type ExamPlanWhereInput = {
    AND?: ExamPlanWhereInput | ExamPlanWhereInput[]
    OR?: ExamPlanWhereInput[]
    NOT?: ExamPlanWhereInput | ExamPlanWhereInput[]
    id?: StringFilter<"ExamPlan"> | string
    title?: StringFilter<"ExamPlan"> | string
    description?: StringFilter<"ExamPlan"> | string
    credit?: IntFilter<"ExamPlan"> | number
    mcqs?: IntFilter<"ExamPlan"> | number
    exams?: IntFilter<"ExamPlan"> | number
    attempts?: IntFilter<"ExamPlan"> | number
    features?: StringNullableListFilter<"ExamPlan">
    aiFeedbackFeatures?: StringNullableListFilter<"ExamPlan">
    enableDownloadReport?: BoolFilter<"ExamPlan"> | boolean
    createdAt?: DateTimeFilter<"ExamPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ExamPlan"> | Date | string
    purchases?: PlanPurchaseListRelationFilter
  }

  export type ExamPlanOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
    features?: SortOrder
    aiFeedbackFeatures?: SortOrder
    enableDownloadReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchases?: PlanPurchaseOrderByRelationAggregateInput
  }

  export type ExamPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamPlanWhereInput | ExamPlanWhereInput[]
    OR?: ExamPlanWhereInput[]
    NOT?: ExamPlanWhereInput | ExamPlanWhereInput[]
    title?: StringFilter<"ExamPlan"> | string
    description?: StringFilter<"ExamPlan"> | string
    credit?: IntFilter<"ExamPlan"> | number
    mcqs?: IntFilter<"ExamPlan"> | number
    exams?: IntFilter<"ExamPlan"> | number
    attempts?: IntFilter<"ExamPlan"> | number
    features?: StringNullableListFilter<"ExamPlan">
    aiFeedbackFeatures?: StringNullableListFilter<"ExamPlan">
    enableDownloadReport?: BoolFilter<"ExamPlan"> | boolean
    createdAt?: DateTimeFilter<"ExamPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ExamPlan"> | Date | string
    purchases?: PlanPurchaseListRelationFilter
  }, "id">

  export type ExamPlanOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
    features?: SortOrder
    aiFeedbackFeatures?: SortOrder
    enableDownloadReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamPlanCountOrderByAggregateInput
    _avg?: ExamPlanAvgOrderByAggregateInput
    _max?: ExamPlanMaxOrderByAggregateInput
    _min?: ExamPlanMinOrderByAggregateInput
    _sum?: ExamPlanSumOrderByAggregateInput
  }

  export type ExamPlanScalarWhereWithAggregatesInput = {
    AND?: ExamPlanScalarWhereWithAggregatesInput | ExamPlanScalarWhereWithAggregatesInput[]
    OR?: ExamPlanScalarWhereWithAggregatesInput[]
    NOT?: ExamPlanScalarWhereWithAggregatesInput | ExamPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamPlan"> | string
    title?: StringWithAggregatesFilter<"ExamPlan"> | string
    description?: StringWithAggregatesFilter<"ExamPlan"> | string
    credit?: IntWithAggregatesFilter<"ExamPlan"> | number
    mcqs?: IntWithAggregatesFilter<"ExamPlan"> | number
    exams?: IntWithAggregatesFilter<"ExamPlan"> | number
    attempts?: IntWithAggregatesFilter<"ExamPlan"> | number
    features?: StringNullableListFilter<"ExamPlan">
    aiFeedbackFeatures?: StringNullableListFilter<"ExamPlan">
    enableDownloadReport?: BoolWithAggregatesFilter<"ExamPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExamPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamPlan"> | Date | string
  }

  export type PlanPurchaseWhereInput = {
    AND?: PlanPurchaseWhereInput | PlanPurchaseWhereInput[]
    OR?: PlanPurchaseWhereInput[]
    NOT?: PlanPurchaseWhereInput | PlanPurchaseWhereInput[]
    id?: StringFilter<"PlanPurchase"> | string
    usedMcqs?: IntFilter<"PlanPurchase"> | number
    usedExams?: IntFilter<"PlanPurchase"> | number
    usedAttempts?: IntFilter<"PlanPurchase"> | number
    status?: StringFilter<"PlanPurchase"> | string
    userId?: StringFilter<"PlanPurchase"> | string
    planId?: StringFilter<"PlanPurchase"> | string
    createdAt?: DateTimeFilter<"PlanPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPurchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<ExamPlanScalarRelationFilter, ExamPlanWhereInput>
  }

  export type PlanPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: ExamPlanOrderByWithRelationInput
  }

  export type PlanPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanPurchaseWhereInput | PlanPurchaseWhereInput[]
    OR?: PlanPurchaseWhereInput[]
    NOT?: PlanPurchaseWhereInput | PlanPurchaseWhereInput[]
    usedMcqs?: IntFilter<"PlanPurchase"> | number
    usedExams?: IntFilter<"PlanPurchase"> | number
    usedAttempts?: IntFilter<"PlanPurchase"> | number
    status?: StringFilter<"PlanPurchase"> | string
    userId?: StringFilter<"PlanPurchase"> | string
    planId?: StringFilter<"PlanPurchase"> | string
    createdAt?: DateTimeFilter<"PlanPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPurchase"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<ExamPlanScalarRelationFilter, ExamPlanWhereInput>
  }, "id">

  export type PlanPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanPurchaseCountOrderByAggregateInput
    _avg?: PlanPurchaseAvgOrderByAggregateInput
    _max?: PlanPurchaseMaxOrderByAggregateInput
    _min?: PlanPurchaseMinOrderByAggregateInput
    _sum?: PlanPurchaseSumOrderByAggregateInput
  }

  export type PlanPurchaseScalarWhereWithAggregatesInput = {
    AND?: PlanPurchaseScalarWhereWithAggregatesInput | PlanPurchaseScalarWhereWithAggregatesInput[]
    OR?: PlanPurchaseScalarWhereWithAggregatesInput[]
    NOT?: PlanPurchaseScalarWhereWithAggregatesInput | PlanPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanPurchase"> | string
    usedMcqs?: IntWithAggregatesFilter<"PlanPurchase"> | number
    usedExams?: IntWithAggregatesFilter<"PlanPurchase"> | number
    usedAttempts?: IntWithAggregatesFilter<"PlanPurchase"> | number
    status?: StringWithAggregatesFilter<"PlanPurchase"> | string
    userId?: StringWithAggregatesFilter<"PlanPurchase"> | string
    planId?: StringWithAggregatesFilter<"PlanPurchase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlanPurchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanPurchase"> | Date | string
  }

  export type ReferWhereInput = {
    AND?: ReferWhereInput | ReferWhereInput[]
    OR?: ReferWhereInput[]
    NOT?: ReferWhereInput | ReferWhereInput[]
    id?: StringFilter<"Refer"> | string
    hasPurchased?: BoolFilter<"Refer"> | boolean
    refererId?: StringFilter<"Refer"> | string
    refereeId?: StringFilter<"Refer"> | string
    createdAt?: DateTimeFilter<"Refer"> | Date | string
    updatedAt?: DateTimeFilter<"Refer"> | Date | string
    referer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReferOrderByWithRelationInput = {
    id?: SortOrder
    hasPurchased?: SortOrder
    refererId?: SortOrder
    refereeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
  }

  export type ReferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refereeId?: string
    AND?: ReferWhereInput | ReferWhereInput[]
    OR?: ReferWhereInput[]
    NOT?: ReferWhereInput | ReferWhereInput[]
    hasPurchased?: BoolFilter<"Refer"> | boolean
    refererId?: StringFilter<"Refer"> | string
    createdAt?: DateTimeFilter<"Refer"> | Date | string
    updatedAt?: DateTimeFilter<"Refer"> | Date | string
    referer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refereeId">

  export type ReferOrderByWithAggregationInput = {
    id?: SortOrder
    hasPurchased?: SortOrder
    refererId?: SortOrder
    refereeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferCountOrderByAggregateInput
    _max?: ReferMaxOrderByAggregateInput
    _min?: ReferMinOrderByAggregateInput
  }

  export type ReferScalarWhereWithAggregatesInput = {
    AND?: ReferScalarWhereWithAggregatesInput | ReferScalarWhereWithAggregatesInput[]
    OR?: ReferScalarWhereWithAggregatesInput[]
    NOT?: ReferScalarWhereWithAggregatesInput | ReferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refer"> | string
    hasPurchased?: BoolWithAggregatesFilter<"Refer"> | boolean
    refererId?: StringWithAggregatesFilter<"Refer"> | string
    refereeId?: StringWithAggregatesFilter<"Refer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Refer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Refer"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    isFeatured?: BoolFilter<"Announcement"> | boolean
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    isFeatured?: BoolFilter<"Announcement"> | boolean
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    isFeatured?: BoolWithAggregatesFilter<"Announcement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type RecommendationWhereInput = {
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    id?: StringFilter<"Recommendation"> | string
    title?: StringFilter<"Recommendation"> | string
    reason?: StringFilter<"Recommendation"> | string
    examId?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeFilter<"Recommendation"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }

  export type RecommendationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    reason?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
  }

  export type RecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    title?: StringFilter<"Recommendation"> | string
    reason?: StringFilter<"Recommendation"> | string
    examId?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeFilter<"Recommendation"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
  }, "id">

  export type RecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    reason?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecommendationCountOrderByAggregateInput
    _max?: RecommendationMaxOrderByAggregateInput
    _min?: RecommendationMinOrderByAggregateInput
  }

  export type RecommendationScalarWhereWithAggregatesInput = {
    AND?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    OR?: RecommendationScalarWhereWithAggregatesInput[]
    NOT?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recommendation"> | string
    title?: StringWithAggregatesFilter<"Recommendation"> | string
    reason?: StringWithAggregatesFilter<"Recommendation"> | string
    examId?: StringWithAggregatesFilter<"Recommendation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassNameCreateInput = {
    id?: string
    name: string
    level: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectCreateNestedManyWithoutClassNamesInput
    chapters?: ChapterCreateNestedManyWithoutClassNamesInput
    exams?: ExamCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateInput = {
    id?: string
    name: string
    level: string
    position?: number
    subjectIds?: ClassNameCreatesubjectIdsInput | string[]
    chapterIds?: ClassNameCreatechapterIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassNamesInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutClassNamesInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUpdateManyWithoutClassNamesNestedInput
    chapters?: ChapterUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutClassNamesNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameCreateManyInput = {
    id?: string
    name: string
    level: string
    position?: number
    subjectIds?: ClassNameCreatesubjectIdsInput | string[]
    chapterIds?: ClassNameCreatechapterIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassNameUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassNameUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    mcqs?: McqCreateNestedManyWithoutSubjectInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    mcqs?: McqUncheckedCreateNestedManyWithoutSubjectInput
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUpdateManyWithoutSubjectNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutSubjectNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
    exams?: ExamCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameCreateNestedManyWithoutChaptersInput
    context?: ChapterContextCreateNestedOneWithoutChapterInput
    mcqs?: McqCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameUncheckedCreateNestedManyWithoutChaptersInput
    context?: ChapterContextUncheckedCreateNestedOneWithoutChapterInput
    mcqs?: McqUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    exams?: ExamUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUpdateOneWithoutChapterNestedInput
    mcqs?: McqUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUncheckedUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUncheckedUpdateOneWithoutChapterNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterContextCreateInput = {
    id?: string
    title: string
    author?: string | null
    authorSummary?: string | null
    content: string
    meaning?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutContextInput
  }

  export type ChapterContextUncheckedCreateInput = {
    id?: string
    title: string
    author?: string | null
    authorSummary?: string | null
    content: string
    meaning?: string | null
    summary?: string | null
    chapterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterContextUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutContextNestedInput
  }

  export type ChapterContextUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterContextCreateManyInput = {
    id?: string
    title: string
    author?: string | null
    authorSummary?: string | null
    content: string
    meaning?: string | null
    summary?: string | null
    chapterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterContextUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterContextUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqCreateInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutMcqsInput
    chapter: ChapterCreateNestedOneWithoutMcqsInput
    exams?: ExamCreateNestedManyWithoutQuestionsInput
  }

  export type McqUncheckedCreateInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    subjectId: string
    chapterId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type McqUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutMcqsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutMcqsNestedInput
    exams?: ExamUpdateManyWithoutQuestionsNestedInput
  }

  export type McqUncheckedUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type McqCreateManyInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    subjectId: string
    chapterId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUncheckedUpdateManyInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptCreateInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutAttemptsInput
    feedback?: ExamFeedbackCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptUncheckedCreateInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    examId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: ExamFeedbackUncheckedCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptUpdateInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    feedback?: ExamFeedbackUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptUncheckedUpdateInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: ExamFeedbackUncheckedUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptCreateManyInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    examId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqAttemptUpdateManyMutationInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptUncheckedUpdateManyInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamFeedbackCreateInput = {
    id?: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mcqAttempt: McqAttemptCreateNestedOneWithoutFeedbackInput
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type ExamFeedbackUncheckedCreateInput = {
    id?: string
    mcqAttemptId: string
    userId: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamFeedbackUpdateInput = {
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqAttempt?: McqAttemptUpdateOneRequiredWithoutFeedbackNestedInput
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type ExamFeedbackUncheckedUpdateInput = {
    mcqAttemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamFeedbackCreateManyInput = {
    id?: string
    mcqAttemptId: string
    userId: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamFeedbackUpdateManyMutationInput = {
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamFeedbackUncheckedUpdateManyInput = {
    mcqAttemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPlanCreateInput = {
    id?: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status?: string
    isPopular?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCreditPlanInput
  }

  export type CreditPlanUncheckedCreateInput = {
    id?: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status?: string
    isPopular?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreditPlanInput
  }

  export type CreditPlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCreditPlanNestedInput
  }

  export type CreditPlanUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCreditPlanNestedInput
  }

  export type CreditPlanCreateManyInput = {
    id?: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status?: string
    isPopular?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditPlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPlanUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    creditPlan: CreditPlanCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    userId: string
    creditPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    creditPlan?: CreditPlanUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    creditPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    userId: string
    creditPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    creditPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamPlanCreateInput = {
    id?: string
    title: string
    description: string
    credit: number
    mcqs?: number
    exams?: number
    attempts?: number
    features?: ExamPlanCreatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanCreateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PlanPurchaseCreateNestedManyWithoutPlanInput
  }

  export type ExamPlanUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    credit: number
    mcqs?: number
    exams?: number
    attempts?: number
    features?: ExamPlanCreatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanCreateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ExamPlanUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PlanPurchaseUpdateManyWithoutPlanNestedInput
  }

  export type ExamPlanUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ExamPlanCreateManyInput = {
    id?: string
    title: string
    description: string
    credit: number
    mcqs?: number
    exams?: number
    attempts?: number
    features?: ExamPlanCreatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanCreateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamPlanUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamPlanUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseCreateInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
    plan: ExamPlanCreateNestedOneWithoutPurchasesInput
  }

  export type PlanPurchaseUncheckedCreateInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    userId: string
    planId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseUpdateInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    plan?: ExamPlanUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PlanPurchaseUncheckedUpdateInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseCreateManyInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    userId: string
    planId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseUpdateManyMutationInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseUncheckedUpdateManyInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferCreateInput = {
    id?: string
    hasPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referer: UserCreateNestedOneWithoutReferredByMeInput
    referee: UserCreateNestedOneWithoutReferredToMeInput
  }

  export type ReferUncheckedCreateInput = {
    id?: string
    hasPurchased?: boolean
    refererId: string
    refereeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferUpdateInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referer?: UserUpdateOneRequiredWithoutReferredByMeNestedInput
    referee?: UserUpdateOneRequiredWithoutReferredToMeNestedInput
  }

  export type ReferUncheckedUpdateInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    refererId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferCreateManyInput = {
    id?: string
    hasPurchased?: boolean
    refererId: string
    refereeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferUpdateManyMutationInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferUncheckedUpdateManyInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    refererId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    isFeatured?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateInput = {
    id?: string
    title: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutRecommendationsInput
  }

  export type RecommendationUncheckedCreateInput = {
    id?: string
    title: string
    reason: string
    examId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutRecommendationsNestedInput
  }

  export type RecommendationUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateManyInput = {
    id?: string
    title: string
    reason: string
    examId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ReferNullableScalarRelationFilter = {
    is?: ReferWhereInput | null
    isNot?: ReferWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type McqAttemptListRelationFilter = {
    every?: McqAttemptWhereInput
    some?: McqAttemptWhereInput
    none?: McqAttemptWhereInput
  }

  export type ExamFeedbackListRelationFilter = {
    every?: ExamFeedbackWhereInput
    some?: ExamFeedbackWhereInput
    none?: ExamFeedbackWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PlanPurchaseListRelationFilter = {
    every?: PlanPurchaseWhereInput
    some?: PlanPurchaseWhereInput
    none?: PlanPurchaseWhereInput
  }

  export type ReferListRelationFilter = {
    every?: ReferWhereInput
    some?: ReferWhereInput
    none?: ReferWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type McqAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    expiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationIdentifierValueCompoundUniqueInput = {
    identifier: string
    value: string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassNameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    position?: SortOrder
    subjectIds?: SortOrder
    chapterIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassNameAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ClassNameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassNameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassNameSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClassNameListRelationFilter = {
    every?: ClassNameWhereInput
    some?: ClassNameWhereInput
    none?: ClassNameWhereInput
  }

  export type McqListRelationFilter = {
    every?: McqWhereInput
    some?: McqWhereInput
    none?: McqWhereInput
  }

  export type ClassNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type McqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type ChapterContextNullableScalarRelationFilter = {
    is?: ChapterContextWhereInput | null
    isNot?: ChapterContextWhereInput | null
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    subjectId?: SortOrder
    examIds?: SortOrder
    classNameIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ChapterScalarRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type ChapterContextCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    authorSummary?: SortOrder
    content?: SortOrder
    meaning?: SortOrder
    summary?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterContextMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    authorSummary?: SortOrder
    content?: SortOrder
    meaning?: SortOrder
    summary?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterContextMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    authorSummary?: SortOrder
    content?: SortOrder
    meaning?: SortOrder
    summary?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    options?: SortOrder
    statements?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    explanation?: SortOrder
    isMath?: SortOrder
    session?: SortOrder
    source?: SortOrder
    questionUrl?: SortOrder
    contextUrl?: SortOrder
    context?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    examIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqAvgOrderByAggregateInput = {
    session?: SortOrder
  }

  export type McqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    explanation?: SortOrder
    isMath?: SortOrder
    session?: SortOrder
    source?: SortOrder
    questionUrl?: SortOrder
    contextUrl?: SortOrder
    context?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    explanation?: SortOrder
    isMath?: SortOrder
    session?: SortOrder
    source?: SortOrder
    questionUrl?: SortOrder
    contextUrl?: SortOrder
    context?: SortOrder
    subjectId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqSumOrderByAggregateInput = {
    session?: SortOrder
  }

  export type ClassNameScalarRelationFilter = {
    is?: ClassNameWhereInput
    isNot?: ClassNameWhereInput
  }

  export type RecommendationListRelationFilter = {
    every?: RecommendationWhereInput
    some?: RecommendationWhereInput
    none?: RecommendationWhereInput
  }

  export type RecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    questionCount?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    classNameId?: SortOrder
    subjectId?: SortOrder
    chapterIds?: SortOrder
    questionIds?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    questionCount?: SortOrder
    duration?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    questionCount?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    classNameId?: SortOrder
    subjectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    questionCount?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    classNameId?: SortOrder
    subjectId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    questionCount?: SortOrder
    duration?: SortOrder
  }

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExamFeedbackNullableScalarRelationFilter = {
    is?: ExamFeedbackWhereInput | null
    isNot?: ExamFeedbackWhereInput | null
  }

  export type McqAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    answers?: SortOrder
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqAttemptAvgOrderByAggregateInput = {
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
  }

  export type McqAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type McqAttemptSumOrderByAggregateInput = {
    total?: SortOrder
    score?: SortOrder
    streak?: SortOrder
    longestStreak?: SortOrder
    wrongAnswer?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type McqAttemptScalarRelationFilter = {
    is?: McqAttemptWhereInput
    isNot?: McqAttemptWhereInput
  }

  export type ExamFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    mcqAttemptId?: SortOrder
    userId?: SortOrder
    overallSummary?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    detailedAnalysis?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamFeedbackAvgOrderByAggregateInput = {
    userRating?: SortOrder
  }

  export type ExamFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    mcqAttemptId?: SortOrder
    userId?: SortOrder
    overallSummary?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    mcqAttemptId?: SortOrder
    userId?: SortOrder
    overallSummary?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamFeedbackSumOrderByAggregateInput = {
    userRating?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type CreditPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
    status?: SortOrder
    isPopular?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditPlanAvgOrderByAggregateInput = {
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
  }

  export type CreditPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
    status?: SortOrder
    isPopular?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
    status?: SortOrder
    isPopular?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditPlanSumOrderByAggregateInput = {
    credit?: SortOrder
    price?: SortOrder
    discount?: SortOrder
    save?: SortOrder
    bonus?: SortOrder
  }

  export type CreditPlanScalarRelationFilter = {
    is?: CreditPlanWhereInput
    isNot?: CreditPlanWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    creditPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    creditPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    creditPlanId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExamPlanCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
    features?: SortOrder
    aiFeedbackFeatures?: SortOrder
    enableDownloadReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamPlanAvgOrderByAggregateInput = {
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
  }

  export type ExamPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
    enableDownloadReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamPlanMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
    enableDownloadReport?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamPlanSumOrderByAggregateInput = {
    credit?: SortOrder
    mcqs?: SortOrder
    exams?: SortOrder
    attempts?: SortOrder
  }

  export type ExamPlanScalarRelationFilter = {
    is?: ExamPlanWhereInput
    isNot?: ExamPlanWhereInput
  }

  export type PlanPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPurchaseAvgOrderByAggregateInput = {
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
  }

  export type PlanPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanPurchaseSumOrderByAggregateInput = {
    usedMcqs?: SortOrder
    usedExams?: SortOrder
    usedAttempts?: SortOrder
  }

  export type ReferCountOrderByAggregateInput = {
    id?: SortOrder
    hasPurchased?: SortOrder
    refererId?: SortOrder
    refereeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferMaxOrderByAggregateInput = {
    id?: SortOrder
    hasPurchased?: SortOrder
    refererId?: SortOrder
    refereeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferMinOrderByAggregateInput = {
    id?: SortOrder
    hasPurchased?: SortOrder
    refererId?: SortOrder
    refereeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isFeatured?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    reason?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    reason?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    reason?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferCreateOrConnectWithoutRefereeInput
    connect?: ReferWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type McqAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput> | McqAttemptCreateWithoutUserInput[] | McqAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutUserInput | McqAttemptCreateOrConnectWithoutUserInput[]
    createMany?: McqAttemptCreateManyUserInputEnvelope
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
  }

  export type ExamFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput> | ExamFeedbackCreateWithoutUserInput[] | ExamFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutUserInput | ExamFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ExamFeedbackCreateManyUserInputEnvelope
    connect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PlanPurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput> | PlanPurchaseCreateWithoutUserInput[] | PlanPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutUserInput | PlanPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PlanPurchaseCreateManyUserInputEnvelope
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
  }

  export type ReferCreateNestedManyWithoutRefererInput = {
    create?: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput> | ReferCreateWithoutRefererInput[] | ReferUncheckedCreateWithoutRefererInput[]
    connectOrCreate?: ReferCreateOrConnectWithoutRefererInput | ReferCreateOrConnectWithoutRefererInput[]
    createMany?: ReferCreateManyRefererInputEnvelope
    connect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
  }

  export type ReferUncheckedCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferCreateOrConnectWithoutRefereeInput
    connect?: ReferWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type McqAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput> | McqAttemptCreateWithoutUserInput[] | McqAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutUserInput | McqAttemptCreateOrConnectWithoutUserInput[]
    createMany?: McqAttemptCreateManyUserInputEnvelope
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
  }

  export type ExamFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput> | ExamFeedbackCreateWithoutUserInput[] | ExamFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutUserInput | ExamFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: ExamFeedbackCreateManyUserInputEnvelope
    connect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PlanPurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput> | PlanPurchaseCreateWithoutUserInput[] | PlanPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutUserInput | PlanPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: PlanPurchaseCreateManyUserInputEnvelope
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
  }

  export type ReferUncheckedCreateNestedManyWithoutRefererInput = {
    create?: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput> | ReferCreateWithoutRefererInput[] | ReferUncheckedCreateWithoutRefererInput[]
    connectOrCreate?: ReferCreateOrConnectWithoutRefererInput | ReferCreateOrConnectWithoutRefererInput[]
    createMany?: ReferCreateManyRefererInputEnvelope
    connect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ReferUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferCreateOrConnectWithoutRefereeInput
    upsert?: ReferUpsertWithoutRefereeInput
    disconnect?: ReferWhereInput | boolean
    delete?: ReferWhereInput | boolean
    connect?: ReferWhereUniqueInput
    update?: XOR<XOR<ReferUpdateToOneWithWhereWithoutRefereeInput, ReferUpdateWithoutRefereeInput>, ReferUncheckedUpdateWithoutRefereeInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUserInput | ExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUserInput | ExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUserInput | ExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type McqAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput> | McqAttemptCreateWithoutUserInput[] | McqAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutUserInput | McqAttemptCreateOrConnectWithoutUserInput[]
    upsert?: McqAttemptUpsertWithWhereUniqueWithoutUserInput | McqAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: McqAttemptCreateManyUserInputEnvelope
    set?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    disconnect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    delete?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    update?: McqAttemptUpdateWithWhereUniqueWithoutUserInput | McqAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: McqAttemptUpdateManyWithWhereWithoutUserInput | McqAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
  }

  export type ExamFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput> | ExamFeedbackCreateWithoutUserInput[] | ExamFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutUserInput | ExamFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ExamFeedbackUpsertWithWhereUniqueWithoutUserInput | ExamFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamFeedbackCreateManyUserInputEnvelope
    set?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    disconnect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    delete?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    connect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    update?: ExamFeedbackUpdateWithWhereUniqueWithoutUserInput | ExamFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamFeedbackUpdateManyWithWhereWithoutUserInput | ExamFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamFeedbackScalarWhereInput | ExamFeedbackScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PlanPurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput> | PlanPurchaseCreateWithoutUserInput[] | PlanPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutUserInput | PlanPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PlanPurchaseUpsertWithWhereUniqueWithoutUserInput | PlanPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanPurchaseCreateManyUserInputEnvelope
    set?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    disconnect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    delete?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    update?: PlanPurchaseUpdateWithWhereUniqueWithoutUserInput | PlanPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanPurchaseUpdateManyWithWhereWithoutUserInput | PlanPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
  }

  export type ReferUpdateManyWithoutRefererNestedInput = {
    create?: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput> | ReferCreateWithoutRefererInput[] | ReferUncheckedCreateWithoutRefererInput[]
    connectOrCreate?: ReferCreateOrConnectWithoutRefererInput | ReferCreateOrConnectWithoutRefererInput[]
    upsert?: ReferUpsertWithWhereUniqueWithoutRefererInput | ReferUpsertWithWhereUniqueWithoutRefererInput[]
    createMany?: ReferCreateManyRefererInputEnvelope
    set?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    disconnect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    delete?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    connect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    update?: ReferUpdateWithWhereUniqueWithoutRefererInput | ReferUpdateWithWhereUniqueWithoutRefererInput[]
    updateMany?: ReferUpdateManyWithWhereWithoutRefererInput | ReferUpdateManyWithWhereWithoutRefererInput[]
    deleteMany?: ReferScalarWhereInput | ReferScalarWhereInput[]
  }

  export type ReferUncheckedUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferCreateOrConnectWithoutRefereeInput
    upsert?: ReferUpsertWithoutRefereeInput
    disconnect?: ReferWhereInput | boolean
    delete?: ReferWhereInput | boolean
    connect?: ReferWhereUniqueInput
    update?: XOR<XOR<ReferUpdateToOneWithWhereWithoutRefereeInput, ReferUpdateWithoutRefereeInput>, ReferUncheckedUpdateWithoutRefereeInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUserInput | ExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUserInput | ExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUserInput | ExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type McqAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput> | McqAttemptCreateWithoutUserInput[] | McqAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutUserInput | McqAttemptCreateOrConnectWithoutUserInput[]
    upsert?: McqAttemptUpsertWithWhereUniqueWithoutUserInput | McqAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: McqAttemptCreateManyUserInputEnvelope
    set?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    disconnect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    delete?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    update?: McqAttemptUpdateWithWhereUniqueWithoutUserInput | McqAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: McqAttemptUpdateManyWithWhereWithoutUserInput | McqAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
  }

  export type ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput> | ExamFeedbackCreateWithoutUserInput[] | ExamFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutUserInput | ExamFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: ExamFeedbackUpsertWithWhereUniqueWithoutUserInput | ExamFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamFeedbackCreateManyUserInputEnvelope
    set?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    disconnect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    delete?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    connect?: ExamFeedbackWhereUniqueInput | ExamFeedbackWhereUniqueInput[]
    update?: ExamFeedbackUpdateWithWhereUniqueWithoutUserInput | ExamFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamFeedbackUpdateManyWithWhereWithoutUserInput | ExamFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamFeedbackScalarWhereInput | ExamFeedbackScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput> | PlanPurchaseCreateWithoutUserInput[] | PlanPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutUserInput | PlanPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: PlanPurchaseUpsertWithWhereUniqueWithoutUserInput | PlanPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlanPurchaseCreateManyUserInputEnvelope
    set?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    disconnect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    delete?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    update?: PlanPurchaseUpdateWithWhereUniqueWithoutUserInput | PlanPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlanPurchaseUpdateManyWithWhereWithoutUserInput | PlanPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
  }

  export type ReferUncheckedUpdateManyWithoutRefererNestedInput = {
    create?: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput> | ReferCreateWithoutRefererInput[] | ReferUncheckedCreateWithoutRefererInput[]
    connectOrCreate?: ReferCreateOrConnectWithoutRefererInput | ReferCreateOrConnectWithoutRefererInput[]
    upsert?: ReferUpsertWithWhereUniqueWithoutRefererInput | ReferUpsertWithWhereUniqueWithoutRefererInput[]
    createMany?: ReferCreateManyRefererInputEnvelope
    set?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    disconnect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    delete?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    connect?: ReferWhereUniqueInput | ReferWhereUniqueInput[]
    update?: ReferUpdateWithWhereUniqueWithoutRefererInput | ReferUpdateWithWhereUniqueWithoutRefererInput[]
    updateMany?: ReferUpdateManyWithWhereWithoutRefererInput | ReferUpdateManyWithWhereWithoutRefererInput[]
    deleteMany?: ReferScalarWhereInput | ReferScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type SubjectCreateNestedManyWithoutClassNamesInput = {
    create?: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput> | SubjectCreateWithoutClassNamesInput[] | SubjectUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassNamesInput | SubjectCreateOrConnectWithoutClassNamesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ChapterCreateNestedManyWithoutClassNamesInput = {
    create?: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput> | ChapterCreateWithoutClassNamesInput[] | ChapterUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutClassNamesInput | ChapterCreateOrConnectWithoutClassNamesInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutClassNameInput = {
    create?: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput> | ExamCreateWithoutClassNameInput[] | ExamUncheckedCreateWithoutClassNameInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassNameInput | ExamCreateOrConnectWithoutClassNameInput[]
    createMany?: ExamCreateManyClassNameInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClassNameCreatesubjectIdsInput = {
    set: string[]
  }

  export type ClassNameCreatechapterIdsInput = {
    set: string[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutClassNamesInput = {
    create?: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput> | SubjectCreateWithoutClassNamesInput[] | SubjectUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassNamesInput | SubjectCreateOrConnectWithoutClassNamesInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutClassNamesInput = {
    create?: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput> | ChapterCreateWithoutClassNamesInput[] | ChapterUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutClassNamesInput | ChapterCreateOrConnectWithoutClassNamesInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutClassNameInput = {
    create?: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput> | ExamCreateWithoutClassNameInput[] | ExamUncheckedCreateWithoutClassNameInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassNameInput | ExamCreateOrConnectWithoutClassNameInput[]
    createMany?: ExamCreateManyClassNameInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SubjectUpdateManyWithoutClassNamesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput> | SubjectCreateWithoutClassNamesInput[] | SubjectUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassNamesInput | SubjectCreateOrConnectWithoutClassNamesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassNamesInput | SubjectUpsertWithWhereUniqueWithoutClassNamesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassNamesInput | SubjectUpdateWithWhereUniqueWithoutClassNamesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassNamesInput | SubjectUpdateManyWithWhereWithoutClassNamesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ChapterUpdateManyWithoutClassNamesNestedInput = {
    create?: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput> | ChapterCreateWithoutClassNamesInput[] | ChapterUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutClassNamesInput | ChapterCreateOrConnectWithoutClassNamesInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutClassNamesInput | ChapterUpsertWithWhereUniqueWithoutClassNamesInput[]
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutClassNamesInput | ChapterUpdateWithWhereUniqueWithoutClassNamesInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutClassNamesInput | ChapterUpdateManyWithWhereWithoutClassNamesInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutClassNameNestedInput = {
    create?: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput> | ExamCreateWithoutClassNameInput[] | ExamUncheckedCreateWithoutClassNameInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassNameInput | ExamCreateOrConnectWithoutClassNameInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutClassNameInput | ExamUpsertWithWhereUniqueWithoutClassNameInput[]
    createMany?: ExamCreateManyClassNameInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutClassNameInput | ExamUpdateWithWhereUniqueWithoutClassNameInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutClassNameInput | ExamUpdateManyWithWhereWithoutClassNameInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClassNameUpdatesubjectIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClassNameUpdatechapterIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubjectUncheckedUpdateManyWithoutClassNamesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput> | SubjectCreateWithoutClassNamesInput[] | SubjectUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutClassNamesInput | SubjectCreateOrConnectWithoutClassNamesInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutClassNamesInput | SubjectUpsertWithWhereUniqueWithoutClassNamesInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutClassNamesInput | SubjectUpdateWithWhereUniqueWithoutClassNamesInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutClassNamesInput | SubjectUpdateManyWithWhereWithoutClassNamesInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutClassNamesNestedInput = {
    create?: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput> | ChapterCreateWithoutClassNamesInput[] | ChapterUncheckedCreateWithoutClassNamesInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutClassNamesInput | ChapterCreateOrConnectWithoutClassNamesInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutClassNamesInput | ChapterUpsertWithWhereUniqueWithoutClassNamesInput[]
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutClassNamesInput | ChapterUpdateWithWhereUniqueWithoutClassNamesInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutClassNamesInput | ChapterUpdateManyWithWhereWithoutClassNamesInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutClassNameNestedInput = {
    create?: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput> | ExamCreateWithoutClassNameInput[] | ExamUncheckedCreateWithoutClassNameInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutClassNameInput | ExamCreateOrConnectWithoutClassNameInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutClassNameInput | ExamUpsertWithWhereUniqueWithoutClassNameInput[]
    createMany?: ExamCreateManyClassNameInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutClassNameInput | ExamUpdateWithWhereUniqueWithoutClassNameInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutClassNameInput | ExamUpdateManyWithWhereWithoutClassNameInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClassNameCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput> | ClassNameCreateWithoutSubjectsInput[] | ClassNameUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutSubjectsInput | ClassNameCreateOrConnectWithoutSubjectsInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type ChapterCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type McqCreateNestedManyWithoutSubjectInput = {
    create?: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput> | McqCreateWithoutSubjectInput[] | McqUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: McqCreateOrConnectWithoutSubjectInput | McqCreateOrConnectWithoutSubjectInput[]
    createMany?: McqCreateManySubjectInputEnvelope
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type SubjectCreateclassNameIdsInput = {
    set: string[]
  }

  export type ClassNameUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput> | ClassNameCreateWithoutSubjectsInput[] | ClassNameUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutSubjectsInput | ClassNameCreateOrConnectWithoutSubjectsInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type McqUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput> | McqCreateWithoutSubjectInput[] | McqUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: McqCreateOrConnectWithoutSubjectInput | McqCreateOrConnectWithoutSubjectInput[]
    createMany?: McqCreateManySubjectInputEnvelope
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClassNameUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput> | ClassNameCreateWithoutSubjectsInput[] | ClassNameUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutSubjectsInput | ClassNameCreateOrConnectWithoutSubjectsInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutSubjectsInput | ClassNameUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutSubjectsInput | ClassNameUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutSubjectsInput | ClassNameUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type ChapterUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type McqUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput> | McqCreateWithoutSubjectInput[] | McqUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: McqCreateOrConnectWithoutSubjectInput | McqCreateOrConnectWithoutSubjectInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutSubjectInput | McqUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: McqCreateManySubjectInputEnvelope
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutSubjectInput | McqUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: McqUpdateManyWithWhereWithoutSubjectInput | McqUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type SubjectUpdateclassNameIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClassNameUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput> | ClassNameCreateWithoutSubjectsInput[] | ClassNameUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutSubjectsInput | ClassNameCreateOrConnectWithoutSubjectsInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutSubjectsInput | ClassNameUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutSubjectsInput | ClassNameUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutSubjectsInput | ClassNameUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type McqUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput> | McqCreateWithoutSubjectInput[] | McqUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: McqCreateOrConnectWithoutSubjectInput | McqCreateOrConnectWithoutSubjectInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutSubjectInput | McqUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: McqCreateManySubjectInputEnvelope
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutSubjectInput | McqUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: McqUpdateManyWithWhereWithoutSubjectInput | McqUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput> | ExamCreateWithoutSubjectInput[] | ExamUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutSubjectInput | ExamCreateOrConnectWithoutSubjectInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutSubjectInput | ExamUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ExamCreateManySubjectInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutSubjectInput | ExamUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutSubjectInput | ExamUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type SubjectCreateNestedOneWithoutChaptersInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
  }

  export type ExamCreateNestedManyWithoutChaptersInput = {
    create?: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput> | ExamCreateWithoutChaptersInput[] | ExamUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutChaptersInput | ExamCreateOrConnectWithoutChaptersInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClassNameCreateNestedManyWithoutChaptersInput = {
    create?: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput> | ClassNameCreateWithoutChaptersInput[] | ClassNameUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutChaptersInput | ClassNameCreateOrConnectWithoutChaptersInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type ChapterContextCreateNestedOneWithoutChapterInput = {
    create?: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
    connectOrCreate?: ChapterContextCreateOrConnectWithoutChapterInput
    connect?: ChapterContextWhereUniqueInput
  }

  export type McqCreateNestedManyWithoutChapterInput = {
    create?: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput> | McqCreateWithoutChapterInput[] | McqUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: McqCreateOrConnectWithoutChapterInput | McqCreateOrConnectWithoutChapterInput[]
    createMany?: McqCreateManyChapterInputEnvelope
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type ChapterCreateexamIdsInput = {
    set: string[]
  }

  export type ChapterCreateclassNameIdsInput = {
    set: string[]
  }

  export type ExamUncheckedCreateNestedManyWithoutChaptersInput = {
    create?: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput> | ExamCreateWithoutChaptersInput[] | ExamUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutChaptersInput | ExamCreateOrConnectWithoutChaptersInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ClassNameUncheckedCreateNestedManyWithoutChaptersInput = {
    create?: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput> | ClassNameCreateWithoutChaptersInput[] | ClassNameUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutChaptersInput | ClassNameCreateOrConnectWithoutChaptersInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type ChapterContextUncheckedCreateNestedOneWithoutChapterInput = {
    create?: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
    connectOrCreate?: ChapterContextCreateOrConnectWithoutChapterInput
    connect?: ChapterContextWhereUniqueInput
  }

  export type McqUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput> | McqCreateWithoutChapterInput[] | McqUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: McqCreateOrConnectWithoutChapterInput | McqCreateOrConnectWithoutChapterInput[]
    createMany?: McqCreateManyChapterInputEnvelope
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type SubjectUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    upsert?: SubjectUpsertWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutChaptersInput, SubjectUpdateWithoutChaptersInput>, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type ExamUpdateManyWithoutChaptersNestedInput = {
    create?: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput> | ExamCreateWithoutChaptersInput[] | ExamUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutChaptersInput | ExamCreateOrConnectWithoutChaptersInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutChaptersInput | ExamUpsertWithWhereUniqueWithoutChaptersInput[]
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutChaptersInput | ExamUpdateWithWhereUniqueWithoutChaptersInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutChaptersInput | ExamUpdateManyWithWhereWithoutChaptersInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClassNameUpdateManyWithoutChaptersNestedInput = {
    create?: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput> | ClassNameCreateWithoutChaptersInput[] | ClassNameUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutChaptersInput | ClassNameCreateOrConnectWithoutChaptersInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutChaptersInput | ClassNameUpsertWithWhereUniqueWithoutChaptersInput[]
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutChaptersInput | ClassNameUpdateWithWhereUniqueWithoutChaptersInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutChaptersInput | ClassNameUpdateManyWithWhereWithoutChaptersInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type ChapterContextUpdateOneWithoutChapterNestedInput = {
    create?: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
    connectOrCreate?: ChapterContextCreateOrConnectWithoutChapterInput
    upsert?: ChapterContextUpsertWithoutChapterInput
    disconnect?: ChapterContextWhereInput | boolean
    delete?: ChapterContextWhereInput | boolean
    connect?: ChapterContextWhereUniqueInput
    update?: XOR<XOR<ChapterContextUpdateToOneWithWhereWithoutChapterInput, ChapterContextUpdateWithoutChapterInput>, ChapterContextUncheckedUpdateWithoutChapterInput>
  }

  export type McqUpdateManyWithoutChapterNestedInput = {
    create?: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput> | McqCreateWithoutChapterInput[] | McqUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: McqCreateOrConnectWithoutChapterInput | McqCreateOrConnectWithoutChapterInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutChapterInput | McqUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: McqCreateManyChapterInputEnvelope
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutChapterInput | McqUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: McqUpdateManyWithWhereWithoutChapterInput | McqUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type ChapterUpdateexamIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChapterUpdateclassNameIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamUncheckedUpdateManyWithoutChaptersNestedInput = {
    create?: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput> | ExamCreateWithoutChaptersInput[] | ExamUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutChaptersInput | ExamCreateOrConnectWithoutChaptersInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutChaptersInput | ExamUpsertWithWhereUniqueWithoutChaptersInput[]
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutChaptersInput | ExamUpdateWithWhereUniqueWithoutChaptersInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutChaptersInput | ExamUpdateManyWithWhereWithoutChaptersInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClassNameUncheckedUpdateManyWithoutChaptersNestedInput = {
    create?: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput> | ClassNameCreateWithoutChaptersInput[] | ClassNameUncheckedCreateWithoutChaptersInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutChaptersInput | ClassNameCreateOrConnectWithoutChaptersInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutChaptersInput | ClassNameUpsertWithWhereUniqueWithoutChaptersInput[]
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutChaptersInput | ClassNameUpdateWithWhereUniqueWithoutChaptersInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutChaptersInput | ClassNameUpdateManyWithWhereWithoutChaptersInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type ChapterContextUncheckedUpdateOneWithoutChapterNestedInput = {
    create?: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
    connectOrCreate?: ChapterContextCreateOrConnectWithoutChapterInput
    upsert?: ChapterContextUpsertWithoutChapterInput
    disconnect?: ChapterContextWhereInput | boolean
    delete?: ChapterContextWhereInput | boolean
    connect?: ChapterContextWhereUniqueInput
    update?: XOR<XOR<ChapterContextUpdateToOneWithWhereWithoutChapterInput, ChapterContextUpdateWithoutChapterInput>, ChapterContextUncheckedUpdateWithoutChapterInput>
  }

  export type McqUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput> | McqCreateWithoutChapterInput[] | McqUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: McqCreateOrConnectWithoutChapterInput | McqCreateOrConnectWithoutChapterInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutChapterInput | McqUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: McqCreateManyChapterInputEnvelope
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutChapterInput | McqUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: McqUpdateManyWithWhereWithoutChapterInput | McqUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type ChapterCreateNestedOneWithoutContextInput = {
    create?: XOR<ChapterCreateWithoutContextInput, ChapterUncheckedCreateWithoutContextInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutContextInput
    connect?: ChapterWhereUniqueInput
  }

  export type ChapterUpdateOneRequiredWithoutContextNestedInput = {
    create?: XOR<ChapterCreateWithoutContextInput, ChapterUncheckedCreateWithoutContextInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutContextInput
    upsert?: ChapterUpsertWithoutContextInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutContextInput, ChapterUpdateWithoutContextInput>, ChapterUncheckedUpdateWithoutContextInput>
  }

  export type McqCreateoptionsInput = {
    set: string[]
  }

  export type McqCreatestatementsInput = {
    set: string[]
  }

  export type SubjectCreateNestedOneWithoutMcqsInput = {
    create?: XOR<SubjectCreateWithoutMcqsInput, SubjectUncheckedCreateWithoutMcqsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutMcqsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutMcqsInput = {
    create?: XOR<ChapterCreateWithoutMcqsInput, ChapterUncheckedCreateWithoutMcqsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutMcqsInput
    connect?: ChapterWhereUniqueInput
  }

  export type ExamCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput> | ExamCreateWithoutQuestionsInput[] | ExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput | ExamCreateOrConnectWithoutQuestionsInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type McqCreateexamIdsInput = {
    set: string[]
  }

  export type ExamUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput> | ExamCreateWithoutQuestionsInput[] | ExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput | ExamCreateOrConnectWithoutQuestionsInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type McqUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type McqUpdatestatementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubjectUpdateOneRequiredWithoutMcqsNestedInput = {
    create?: XOR<SubjectCreateWithoutMcqsInput, SubjectUncheckedCreateWithoutMcqsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutMcqsInput
    upsert?: SubjectUpsertWithoutMcqsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutMcqsInput, SubjectUpdateWithoutMcqsInput>, SubjectUncheckedUpdateWithoutMcqsInput>
  }

  export type ChapterUpdateOneRequiredWithoutMcqsNestedInput = {
    create?: XOR<ChapterCreateWithoutMcqsInput, ChapterUncheckedCreateWithoutMcqsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutMcqsInput
    upsert?: ChapterUpsertWithoutMcqsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutMcqsInput, ChapterUpdateWithoutMcqsInput>, ChapterUncheckedUpdateWithoutMcqsInput>
  }

  export type ExamUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput> | ExamCreateWithoutQuestionsInput[] | ExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput | ExamCreateOrConnectWithoutQuestionsInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutQuestionsInput | ExamUpsertWithWhereUniqueWithoutQuestionsInput[]
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutQuestionsInput | ExamUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutQuestionsInput | ExamUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type McqUpdateexamIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput> | ExamCreateWithoutQuestionsInput[] | ExamUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput | ExamCreateOrConnectWithoutQuestionsInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutQuestionsInput | ExamUpsertWithWhereUniqueWithoutQuestionsInput[]
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutQuestionsInput | ExamUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutQuestionsInput | ExamUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ClassNameCreateNestedOneWithoutExamsInput = {
    create?: XOR<ClassNameCreateWithoutExamsInput, ClassNameUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ClassNameCreateOrConnectWithoutExamsInput
    connect?: ClassNameWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutExamsInput = {
    create?: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutExamsInput = {
    create?: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput> | ChapterCreateWithoutExamsInput[] | ChapterUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutExamsInput | ChapterCreateOrConnectWithoutExamsInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type McqCreateNestedManyWithoutExamsInput = {
    create?: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput> | McqCreateWithoutExamsInput[] | McqUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: McqCreateOrConnectWithoutExamsInput | McqCreateOrConnectWithoutExamsInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutExamsInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    connect?: UserWhereUniqueInput
  }

  export type McqAttemptCreateNestedManyWithoutExamInput = {
    create?: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput> | McqAttemptCreateWithoutExamInput[] | McqAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutExamInput | McqAttemptCreateOrConnectWithoutExamInput[]
    createMany?: McqAttemptCreateManyExamInputEnvelope
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
  }

  export type RecommendationCreateNestedManyWithoutExamInput = {
    create?: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput> | RecommendationCreateWithoutExamInput[] | RecommendationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutExamInput | RecommendationCreateOrConnectWithoutExamInput[]
    createMany?: RecommendationCreateManyExamInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type ExamCreatechapterIdsInput = {
    set: string[]
  }

  export type ExamCreatequestionIdsInput = {
    set: string[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput> | ChapterCreateWithoutExamsInput[] | ChapterUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutExamsInput | ChapterCreateOrConnectWithoutExamsInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type McqUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput> | McqCreateWithoutExamsInput[] | McqUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: McqCreateOrConnectWithoutExamsInput | McqCreateOrConnectWithoutExamsInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
  }

  export type McqAttemptUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput> | McqAttemptCreateWithoutExamInput[] | McqAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutExamInput | McqAttemptCreateOrConnectWithoutExamInput[]
    createMany?: McqAttemptCreateManyExamInputEnvelope
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
  }

  export type RecommendationUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput> | RecommendationCreateWithoutExamInput[] | RecommendationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutExamInput | RecommendationCreateOrConnectWithoutExamInput[]
    createMany?: RecommendationCreateManyExamInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type ClassNameUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<ClassNameCreateWithoutExamsInput, ClassNameUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ClassNameCreateOrConnectWithoutExamsInput
    upsert?: ClassNameUpsertWithoutExamsInput
    connect?: ClassNameWhereUniqueInput
    update?: XOR<XOR<ClassNameUpdateToOneWithWhereWithoutExamsInput, ClassNameUpdateWithoutExamsInput>, ClassNameUncheckedUpdateWithoutExamsInput>
  }

  export type SubjectUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutExamsInput
    upsert?: SubjectUpsertWithoutExamsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutExamsInput, SubjectUpdateWithoutExamsInput>, SubjectUncheckedUpdateWithoutExamsInput>
  }

  export type ChapterUpdateManyWithoutExamsNestedInput = {
    create?: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput> | ChapterCreateWithoutExamsInput[] | ChapterUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutExamsInput | ChapterCreateOrConnectWithoutExamsInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutExamsInput | ChapterUpsertWithWhereUniqueWithoutExamsInput[]
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutExamsInput | ChapterUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutExamsInput | ChapterUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type McqUpdateManyWithoutExamsNestedInput = {
    create?: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput> | McqCreateWithoutExamsInput[] | McqUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: McqCreateOrConnectWithoutExamsInput | McqCreateOrConnectWithoutExamsInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutExamsInput | McqUpsertWithWhereUniqueWithoutExamsInput[]
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutExamsInput | McqUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: McqUpdateManyWithWhereWithoutExamsInput | McqUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    upsert?: UserUpsertWithoutExamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamsInput, UserUpdateWithoutExamsInput>, UserUncheckedUpdateWithoutExamsInput>
  }

  export type McqAttemptUpdateManyWithoutExamNestedInput = {
    create?: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput> | McqAttemptCreateWithoutExamInput[] | McqAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutExamInput | McqAttemptCreateOrConnectWithoutExamInput[]
    upsert?: McqAttemptUpsertWithWhereUniqueWithoutExamInput | McqAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: McqAttemptCreateManyExamInputEnvelope
    set?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    disconnect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    delete?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    update?: McqAttemptUpdateWithWhereUniqueWithoutExamInput | McqAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: McqAttemptUpdateManyWithWhereWithoutExamInput | McqAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
  }

  export type RecommendationUpdateManyWithoutExamNestedInput = {
    create?: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput> | RecommendationCreateWithoutExamInput[] | RecommendationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutExamInput | RecommendationCreateOrConnectWithoutExamInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutExamInput | RecommendationUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: RecommendationCreateManyExamInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutExamInput | RecommendationUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutExamInput | RecommendationUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type ExamUpdatechapterIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamUpdatequestionIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChapterUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput> | ChapterCreateWithoutExamsInput[] | ChapterUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutExamsInput | ChapterCreateOrConnectWithoutExamsInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutExamsInput | ChapterUpsertWithWhereUniqueWithoutExamsInput[]
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutExamsInput | ChapterUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutExamsInput | ChapterUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type McqUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput> | McqCreateWithoutExamsInput[] | McqUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: McqCreateOrConnectWithoutExamsInput | McqCreateOrConnectWithoutExamsInput[]
    upsert?: McqUpsertWithWhereUniqueWithoutExamsInput | McqUpsertWithWhereUniqueWithoutExamsInput[]
    set?: McqWhereUniqueInput | McqWhereUniqueInput[]
    disconnect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    delete?: McqWhereUniqueInput | McqWhereUniqueInput[]
    connect?: McqWhereUniqueInput | McqWhereUniqueInput[]
    update?: McqUpdateWithWhereUniqueWithoutExamsInput | McqUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: McqUpdateManyWithWhereWithoutExamsInput | McqUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: McqScalarWhereInput | McqScalarWhereInput[]
  }

  export type McqAttemptUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput> | McqAttemptCreateWithoutExamInput[] | McqAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: McqAttemptCreateOrConnectWithoutExamInput | McqAttemptCreateOrConnectWithoutExamInput[]
    upsert?: McqAttemptUpsertWithWhereUniqueWithoutExamInput | McqAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: McqAttemptCreateManyExamInputEnvelope
    set?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    disconnect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    delete?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    connect?: McqAttemptWhereUniqueInput | McqAttemptWhereUniqueInput[]
    update?: McqAttemptUpdateWithWhereUniqueWithoutExamInput | McqAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: McqAttemptUpdateManyWithWhereWithoutExamInput | McqAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
  }

  export type RecommendationUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput> | RecommendationCreateWithoutExamInput[] | RecommendationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutExamInput | RecommendationCreateOrConnectWithoutExamInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutExamInput | RecommendationUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: RecommendationCreateManyExamInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutExamInput | RecommendationUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutExamInput | RecommendationUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type McqAttemptCreateanswersInput = {
    set: string[]
  }

  export type ExamCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamFeedbackCreateNestedOneWithoutMcqAttemptInput = {
    create?: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutMcqAttemptInput
    connect?: ExamFeedbackWhereUniqueInput
  }

  export type ExamFeedbackUncheckedCreateNestedOneWithoutMcqAttemptInput = {
    create?: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutMcqAttemptInput
    connect?: ExamFeedbackWhereUniqueInput
  }

  export type McqAttemptUpdateanswersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    upsert?: ExamUpsertWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutAttemptsInput, ExamUpdateWithoutAttemptsInput>, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttemptsInput
    upsert?: UserUpsertWithoutAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttemptsInput, UserUpdateWithoutAttemptsInput>, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamFeedbackUpdateOneWithoutMcqAttemptNestedInput = {
    create?: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutMcqAttemptInput
    upsert?: ExamFeedbackUpsertWithoutMcqAttemptInput
    disconnect?: ExamFeedbackWhereInput | boolean
    delete?: ExamFeedbackWhereInput | boolean
    connect?: ExamFeedbackWhereUniqueInput
    update?: XOR<XOR<ExamFeedbackUpdateToOneWithWhereWithoutMcqAttemptInput, ExamFeedbackUpdateWithoutMcqAttemptInput>, ExamFeedbackUncheckedUpdateWithoutMcqAttemptInput>
  }

  export type ExamFeedbackUncheckedUpdateOneWithoutMcqAttemptNestedInput = {
    create?: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
    connectOrCreate?: ExamFeedbackCreateOrConnectWithoutMcqAttemptInput
    upsert?: ExamFeedbackUpsertWithoutMcqAttemptInput
    disconnect?: ExamFeedbackWhereInput | boolean
    delete?: ExamFeedbackWhereInput | boolean
    connect?: ExamFeedbackWhereUniqueInput
    update?: XOR<XOR<ExamFeedbackUpdateToOneWithWhereWithoutMcqAttemptInput, ExamFeedbackUpdateWithoutMcqAttemptInput>, ExamFeedbackUncheckedUpdateWithoutMcqAttemptInput>
  }

  export type ExamFeedbackCreatestrengthsInput = {
    set: string[]
  }

  export type ExamFeedbackCreateweaknessesInput = {
    set: string[]
  }

  export type ExamFeedbackCreaterecommendationsInput = {
    set: string[]
  }

  export type McqAttemptCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<McqAttemptCreateWithoutFeedbackInput, McqAttemptUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: McqAttemptCreateOrConnectWithoutFeedbackInput
    connect?: McqAttemptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type ExamFeedbackUpdatestrengthsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamFeedbackUpdateweaknessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamFeedbackUpdaterecommendationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type McqAttemptUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<McqAttemptCreateWithoutFeedbackInput, McqAttemptUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: McqAttemptCreateOrConnectWithoutFeedbackInput
    upsert?: McqAttemptUpsertWithoutFeedbackInput
    connect?: McqAttemptWhereUniqueInput
    update?: XOR<XOR<McqAttemptUpdateToOneWithWhereWithoutFeedbackInput, McqAttemptUpdateWithoutFeedbackInput>, McqAttemptUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type TransactionCreateNestedManyWithoutCreditPlanInput = {
    create?: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput> | TransactionCreateWithoutCreditPlanInput[] | TransactionUncheckedCreateWithoutCreditPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditPlanInput | TransactionCreateOrConnectWithoutCreditPlanInput[]
    createMany?: TransactionCreateManyCreditPlanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreditPlanInput = {
    create?: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput> | TransactionCreateWithoutCreditPlanInput[] | TransactionUncheckedCreateWithoutCreditPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditPlanInput | TransactionCreateOrConnectWithoutCreditPlanInput[]
    createMany?: TransactionCreateManyCreditPlanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutCreditPlanNestedInput = {
    create?: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput> | TransactionCreateWithoutCreditPlanInput[] | TransactionUncheckedCreateWithoutCreditPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditPlanInput | TransactionCreateOrConnectWithoutCreditPlanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreditPlanInput | TransactionUpsertWithWhereUniqueWithoutCreditPlanInput[]
    createMany?: TransactionCreateManyCreditPlanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreditPlanInput | TransactionUpdateWithWhereUniqueWithoutCreditPlanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreditPlanInput | TransactionUpdateManyWithWhereWithoutCreditPlanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreditPlanNestedInput = {
    create?: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput> | TransactionCreateWithoutCreditPlanInput[] | TransactionUncheckedCreateWithoutCreditPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreditPlanInput | TransactionCreateOrConnectWithoutCreditPlanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreditPlanInput | TransactionUpsertWithWhereUniqueWithoutCreditPlanInput[]
    createMany?: TransactionCreateManyCreditPlanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreditPlanInput | TransactionUpdateWithWhereUniqueWithoutCreditPlanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreditPlanInput | TransactionUpdateManyWithWhereWithoutCreditPlanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CreditPlanCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CreditPlanCreateWithoutTransactionsInput, CreditPlanUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreditPlanCreateOrConnectWithoutTransactionsInput
    connect?: CreditPlanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type CreditPlanUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CreditPlanCreateWithoutTransactionsInput, CreditPlanUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CreditPlanCreateOrConnectWithoutTransactionsInput
    upsert?: CreditPlanUpsertWithoutTransactionsInput
    connect?: CreditPlanWhereUniqueInput
    update?: XOR<XOR<CreditPlanUpdateToOneWithWhereWithoutTransactionsInput, CreditPlanUpdateWithoutTransactionsInput>, CreditPlanUncheckedUpdateWithoutTransactionsInput>
  }

  export type ExamPlanCreatefeaturesInput = {
    set: string[]
  }

  export type ExamPlanCreateaiFeedbackFeaturesInput = {
    set: string[]
  }

  export type PlanPurchaseCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput> | PlanPurchaseCreateWithoutPlanInput[] | PlanPurchaseUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutPlanInput | PlanPurchaseCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPurchaseCreateManyPlanInputEnvelope
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
  }

  export type PlanPurchaseUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput> | PlanPurchaseCreateWithoutPlanInput[] | PlanPurchaseUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutPlanInput | PlanPurchaseCreateOrConnectWithoutPlanInput[]
    createMany?: PlanPurchaseCreateManyPlanInputEnvelope
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
  }

  export type ExamPlanUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExamPlanUpdateaiFeedbackFeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanPurchaseUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput> | PlanPurchaseCreateWithoutPlanInput[] | PlanPurchaseUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutPlanInput | PlanPurchaseCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPurchaseUpsertWithWhereUniqueWithoutPlanInput | PlanPurchaseUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPurchaseCreateManyPlanInputEnvelope
    set?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    disconnect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    delete?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    update?: PlanPurchaseUpdateWithWhereUniqueWithoutPlanInput | PlanPurchaseUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPurchaseUpdateManyWithWhereWithoutPlanInput | PlanPurchaseUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
  }

  export type PlanPurchaseUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput> | PlanPurchaseCreateWithoutPlanInput[] | PlanPurchaseUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanPurchaseCreateOrConnectWithoutPlanInput | PlanPurchaseCreateOrConnectWithoutPlanInput[]
    upsert?: PlanPurchaseUpsertWithWhereUniqueWithoutPlanInput | PlanPurchaseUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanPurchaseCreateManyPlanInputEnvelope
    set?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    disconnect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    delete?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    connect?: PlanPurchaseWhereUniqueInput | PlanPurchaseWhereUniqueInput[]
    update?: PlanPurchaseUpdateWithWhereUniqueWithoutPlanInput | PlanPurchaseUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanPurchaseUpdateManyWithWhereWithoutPlanInput | PlanPurchaseUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type ExamPlanCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<ExamPlanCreateWithoutPurchasesInput, ExamPlanUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ExamPlanCreateOrConnectWithoutPurchasesInput
    connect?: ExamPlanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type ExamPlanUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<ExamPlanCreateWithoutPurchasesInput, ExamPlanUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: ExamPlanCreateOrConnectWithoutPurchasesInput
    upsert?: ExamPlanUpsertWithoutPurchasesInput
    connect?: ExamPlanWhereUniqueInput
    update?: XOR<XOR<ExamPlanUpdateToOneWithWhereWithoutPurchasesInput, ExamPlanUpdateWithoutPurchasesInput>, ExamPlanUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserCreateNestedOneWithoutReferredByMeInput = {
    create?: XOR<UserCreateWithoutReferredByMeInput, UserUncheckedCreateWithoutReferredByMeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByMeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredToMeInput = {
    create?: XOR<UserCreateWithoutReferredToMeInput, UserUncheckedCreateWithoutReferredToMeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredToMeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferredByMeNestedInput = {
    create?: XOR<UserCreateWithoutReferredByMeInput, UserUncheckedCreateWithoutReferredByMeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByMeInput
    upsert?: UserUpsertWithoutReferredByMeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredByMeInput, UserUpdateWithoutReferredByMeInput>, UserUncheckedUpdateWithoutReferredByMeInput>
  }

  export type UserUpdateOneRequiredWithoutReferredToMeNestedInput = {
    create?: XOR<UserCreateWithoutReferredToMeInput, UserUncheckedCreateWithoutReferredToMeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredToMeInput
    upsert?: UserUpsertWithoutReferredToMeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredToMeInput, UserUpdateWithoutReferredToMeInput>, UserUncheckedUpdateWithoutReferredToMeInput>
  }

  export type ExamCreateNestedOneWithoutRecommendationsInput = {
    create?: XOR<ExamCreateWithoutRecommendationsInput, ExamUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutRecommendationsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamUpdateOneRequiredWithoutRecommendationsNestedInput = {
    create?: XOR<ExamCreateWithoutRecommendationsInput, ExamUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutRecommendationsInput
    upsert?: ExamUpsertWithoutRecommendationsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutRecommendationsInput, ExamUpdateWithoutRecommendationsInput>, ExamUncheckedUpdateWithoutRecommendationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ReferCreateWithoutRefereeInput = {
    id?: string
    hasPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referer: UserCreateNestedOneWithoutReferredByMeInput
  }

  export type ReferUncheckedCreateWithoutRefereeInput = {
    id?: string
    hasPurchased?: boolean
    refererId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferCreateOrConnectWithoutRefereeInput = {
    where: ReferWhereUniqueInput
    create: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type ExamCreateWithoutUserInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutUserInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput>
  }

  export type ExamCreateManyUserInputEnvelope = {
    data: ExamCreateManyUserInput | ExamCreateManyUserInput[]
  }

  export type McqAttemptCreateWithoutUserInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutAttemptsInput
    feedback?: ExamFeedbackCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    examId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: ExamFeedbackUncheckedCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptCreateOrConnectWithoutUserInput = {
    where: McqAttemptWhereUniqueInput
    create: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput>
  }

  export type McqAttemptCreateManyUserInputEnvelope = {
    data: McqAttemptCreateManyUserInput | McqAttemptCreateManyUserInput[]
  }

  export type ExamFeedbackCreateWithoutUserInput = {
    id?: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mcqAttempt: McqAttemptCreateNestedOneWithoutFeedbackInput
  }

  export type ExamFeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    mcqAttemptId: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamFeedbackCreateOrConnectWithoutUserInput = {
    where: ExamFeedbackWhereUniqueInput
    create: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ExamFeedbackCreateManyUserInputEnvelope = {
    data: ExamFeedbackCreateManyUserInput | ExamFeedbackCreateManyUserInput[]
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creditPlan: CreditPlanCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    creditPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
  }

  export type PlanPurchaseCreateWithoutUserInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: ExamPlanCreateNestedOneWithoutPurchasesInput
  }

  export type PlanPurchaseUncheckedCreateWithoutUserInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    planId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseCreateOrConnectWithoutUserInput = {
    where: PlanPurchaseWhereUniqueInput
    create: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput>
  }

  export type PlanPurchaseCreateManyUserInputEnvelope = {
    data: PlanPurchaseCreateManyUserInput | PlanPurchaseCreateManyUserInput[]
  }

  export type ReferCreateWithoutRefererInput = {
    id?: string
    hasPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    referee: UserCreateNestedOneWithoutReferredToMeInput
  }

  export type ReferUncheckedCreateWithoutRefererInput = {
    id?: string
    hasPurchased?: boolean
    refereeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferCreateOrConnectWithoutRefererInput = {
    where: ReferWhereUniqueInput
    create: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput>
  }

  export type ReferCreateManyRefererInputEnvelope = {
    data: ReferCreateManyRefererInput | ReferCreateManyRefererInput[]
  }

  export type ReferUpsertWithoutRefereeInput = {
    update: XOR<ReferUpdateWithoutRefereeInput, ReferUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferCreateWithoutRefereeInput, ReferUncheckedCreateWithoutRefereeInput>
    where?: ReferWhereInput
  }

  export type ReferUpdateToOneWithWhereWithoutRefereeInput = {
    where?: ReferWhereInput
    data: XOR<ReferUpdateWithoutRefereeInput, ReferUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferUpdateWithoutRefereeInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referer?: UserUpdateOneRequiredWithoutReferredByMeNestedInput
  }

  export type ReferUncheckedUpdateWithoutRefereeInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    refererId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutUserInput, ExamUncheckedUpdateWithoutUserInput>
    create: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutUserInput, ExamUncheckedUpdateWithoutUserInput>
  }

  export type ExamUpdateManyWithWhereWithoutUserInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    questionCount?: IntFilter<"Exam"> | number
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    classNameId?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    chapterIds?: StringNullableListFilter<"Exam">
    questionIds?: StringNullableListFilter<"Exam">
    userId?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type McqAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: McqAttemptWhereUniqueInput
    update: XOR<McqAttemptUpdateWithoutUserInput, McqAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<McqAttemptCreateWithoutUserInput, McqAttemptUncheckedCreateWithoutUserInput>
  }

  export type McqAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: McqAttemptWhereUniqueInput
    data: XOR<McqAttemptUpdateWithoutUserInput, McqAttemptUncheckedUpdateWithoutUserInput>
  }

  export type McqAttemptUpdateManyWithWhereWithoutUserInput = {
    where: McqAttemptScalarWhereInput
    data: XOR<McqAttemptUpdateManyMutationInput, McqAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type McqAttemptScalarWhereInput = {
    AND?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
    OR?: McqAttemptScalarWhereInput[]
    NOT?: McqAttemptScalarWhereInput | McqAttemptScalarWhereInput[]
    id?: StringFilter<"McqAttempt"> | string
    answers?: StringNullableListFilter<"McqAttempt">
    total?: IntFilter<"McqAttempt"> | number
    score?: IntFilter<"McqAttempt"> | number
    streak?: IntFilter<"McqAttempt"> | number
    longestStreak?: IntFilter<"McqAttempt"> | number
    wrongAnswer?: IntFilter<"McqAttempt"> | number
    status?: StringFilter<"McqAttempt"> | string
    startTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    endTime?: DateTimeNullableFilter<"McqAttempt"> | Date | string | null
    examId?: StringFilter<"McqAttempt"> | string
    userId?: StringFilter<"McqAttempt"> | string
    createdAt?: DateTimeFilter<"McqAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"McqAttempt"> | Date | string
  }

  export type ExamFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamFeedbackWhereUniqueInput
    update: XOR<ExamFeedbackUpdateWithoutUserInput, ExamFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<ExamFeedbackCreateWithoutUserInput, ExamFeedbackUncheckedCreateWithoutUserInput>
  }

  export type ExamFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamFeedbackWhereUniqueInput
    data: XOR<ExamFeedbackUpdateWithoutUserInput, ExamFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type ExamFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: ExamFeedbackScalarWhereInput
    data: XOR<ExamFeedbackUpdateManyMutationInput, ExamFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamFeedbackScalarWhereInput = {
    AND?: ExamFeedbackScalarWhereInput | ExamFeedbackScalarWhereInput[]
    OR?: ExamFeedbackScalarWhereInput[]
    NOT?: ExamFeedbackScalarWhereInput | ExamFeedbackScalarWhereInput[]
    id?: StringFilter<"ExamFeedback"> | string
    mcqAttemptId?: StringFilter<"ExamFeedback"> | string
    userId?: StringFilter<"ExamFeedback"> | string
    overallSummary?: StringFilter<"ExamFeedback"> | string
    strengths?: StringNullableListFilter<"ExamFeedback">
    weaknesses?: StringNullableListFilter<"ExamFeedback">
    recommendations?: StringNullableListFilter<"ExamFeedback">
    detailedAnalysis?: JsonNullableFilter<"ExamFeedback">
    userRating?: IntNullableFilter<"ExamFeedback"> | number | null
    createdAt?: DateTimeFilter<"ExamFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"ExamFeedback"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    transactionId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    type?: StringFilter<"Transaction"> | string
    method?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    creditPlanId?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type PlanPurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: PlanPurchaseWhereUniqueInput
    update: XOR<PlanPurchaseUpdateWithoutUserInput, PlanPurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<PlanPurchaseCreateWithoutUserInput, PlanPurchaseUncheckedCreateWithoutUserInput>
  }

  export type PlanPurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: PlanPurchaseWhereUniqueInput
    data: XOR<PlanPurchaseUpdateWithoutUserInput, PlanPurchaseUncheckedUpdateWithoutUserInput>
  }

  export type PlanPurchaseUpdateManyWithWhereWithoutUserInput = {
    where: PlanPurchaseScalarWhereInput
    data: XOR<PlanPurchaseUpdateManyMutationInput, PlanPurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type PlanPurchaseScalarWhereInput = {
    AND?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
    OR?: PlanPurchaseScalarWhereInput[]
    NOT?: PlanPurchaseScalarWhereInput | PlanPurchaseScalarWhereInput[]
    id?: StringFilter<"PlanPurchase"> | string
    usedMcqs?: IntFilter<"PlanPurchase"> | number
    usedExams?: IntFilter<"PlanPurchase"> | number
    usedAttempts?: IntFilter<"PlanPurchase"> | number
    status?: StringFilter<"PlanPurchase"> | string
    userId?: StringFilter<"PlanPurchase"> | string
    planId?: StringFilter<"PlanPurchase"> | string
    createdAt?: DateTimeFilter<"PlanPurchase"> | Date | string
    updatedAt?: DateTimeFilter<"PlanPurchase"> | Date | string
  }

  export type ReferUpsertWithWhereUniqueWithoutRefererInput = {
    where: ReferWhereUniqueInput
    update: XOR<ReferUpdateWithoutRefererInput, ReferUncheckedUpdateWithoutRefererInput>
    create: XOR<ReferCreateWithoutRefererInput, ReferUncheckedCreateWithoutRefererInput>
  }

  export type ReferUpdateWithWhereUniqueWithoutRefererInput = {
    where: ReferWhereUniqueInput
    data: XOR<ReferUpdateWithoutRefererInput, ReferUncheckedUpdateWithoutRefererInput>
  }

  export type ReferUpdateManyWithWhereWithoutRefererInput = {
    where: ReferScalarWhereInput
    data: XOR<ReferUpdateManyMutationInput, ReferUncheckedUpdateManyWithoutRefererInput>
  }

  export type ReferScalarWhereInput = {
    AND?: ReferScalarWhereInput | ReferScalarWhereInput[]
    OR?: ReferScalarWhereInput[]
    NOT?: ReferScalarWhereInput | ReferScalarWhereInput[]
    id?: StringFilter<"Refer"> | string
    hasPurchased?: BoolFilter<"Refer"> | boolean
    refererId?: StringFilter<"Refer"> | string
    refereeId?: StringFilter<"Refer"> | string
    createdAt?: DateTimeFilter<"Refer"> | Date | string
    updatedAt?: DateTimeFilter<"Refer"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type SubjectCreateWithoutClassNamesInput = {
    id?: string
    name: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    mcqs?: McqCreateNestedManyWithoutSubjectInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassNamesInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    mcqs?: McqUncheckedCreateNestedManyWithoutSubjectInput
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassNamesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput>
  }

  export type ChapterCreateWithoutClassNamesInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
    exams?: ExamCreateNestedManyWithoutChaptersInput
    context?: ChapterContextCreateNestedOneWithoutChapterInput
    mcqs?: McqCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutClassNamesInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutChaptersInput
    context?: ChapterContextUncheckedCreateNestedOneWithoutChapterInput
    mcqs?: McqUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutClassNamesInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput>
  }

  export type ExamCreateWithoutClassNameInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutClassNameInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutClassNameInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput>
  }

  export type ExamCreateManyClassNameInputEnvelope = {
    data: ExamCreateManyClassNameInput | ExamCreateManyClassNameInput[]
  }

  export type SubjectUpsertWithWhereUniqueWithoutClassNamesInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutClassNamesInput, SubjectUncheckedUpdateWithoutClassNamesInput>
    create: XOR<SubjectCreateWithoutClassNamesInput, SubjectUncheckedCreateWithoutClassNamesInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutClassNamesInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutClassNamesInput, SubjectUncheckedUpdateWithoutClassNamesInput>
  }

  export type SubjectUpdateManyWithWhereWithoutClassNamesInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutClassNamesInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    group?: StringNullableFilter<"Subject"> | string | null
    classNameIds?: StringNullableListFilter<"Subject">
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutClassNamesInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutClassNamesInput, ChapterUncheckedUpdateWithoutClassNamesInput>
    create: XOR<ChapterCreateWithoutClassNamesInput, ChapterUncheckedCreateWithoutClassNamesInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutClassNamesInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutClassNamesInput, ChapterUncheckedUpdateWithoutClassNamesInput>
  }

  export type ChapterUpdateManyWithWhereWithoutClassNamesInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutClassNamesInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    name?: StringFilter<"Chapter"> | string
    position?: IntFilter<"Chapter"> | number
    subjectId?: StringFilter<"Chapter"> | string
    examIds?: StringNullableListFilter<"Chapter">
    classNameIds?: StringNullableListFilter<"Chapter">
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutClassNameInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutClassNameInput, ExamUncheckedUpdateWithoutClassNameInput>
    create: XOR<ExamCreateWithoutClassNameInput, ExamUncheckedCreateWithoutClassNameInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutClassNameInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutClassNameInput, ExamUncheckedUpdateWithoutClassNameInput>
  }

  export type ExamUpdateManyWithWhereWithoutClassNameInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutClassNameInput>
  }

  export type ClassNameCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterCreateNestedManyWithoutClassNamesInput
    exams?: ExamCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: string
    position?: number
    subjectIds?: ClassNameCreatesubjectIdsInput | string[]
    chapterIds?: ClassNameCreatechapterIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutClassNamesInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameCreateOrConnectWithoutSubjectsInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput>
  }

  export type ChapterCreateWithoutSubjectInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameCreateNestedManyWithoutChaptersInput
    context?: ChapterContextCreateNestedOneWithoutChapterInput
    mcqs?: McqCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutSubjectInput = {
    id?: string
    name: string
    position?: number
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameUncheckedCreateNestedManyWithoutChaptersInput
    context?: ChapterContextUncheckedCreateNestedOneWithoutChapterInput
    mcqs?: McqUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterCreateManySubjectInputEnvelope = {
    data: ChapterCreateManySubjectInput | ChapterCreateManySubjectInput[]
  }

  export type McqCreateWithoutSubjectInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutMcqsInput
    exams?: ExamCreateNestedManyWithoutQuestionsInput
  }

  export type McqUncheckedCreateWithoutSubjectInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    chapterId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type McqCreateOrConnectWithoutSubjectInput = {
    where: McqWhereUniqueInput
    create: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput>
  }

  export type McqCreateManySubjectInputEnvelope = {
    data: McqCreateManySubjectInput | McqCreateManySubjectInput[]
  }

  export type ExamCreateWithoutSubjectInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamCreateManySubjectInputEnvelope = {
    data: ExamCreateManySubjectInput | ExamCreateManySubjectInput[]
  }

  export type ClassNameUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: ClassNameWhereUniqueInput
    update: XOR<ClassNameUpdateWithoutSubjectsInput, ClassNameUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassNameCreateWithoutSubjectsInput, ClassNameUncheckedCreateWithoutSubjectsInput>
  }

  export type ClassNameUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: ClassNameWhereUniqueInput
    data: XOR<ClassNameUpdateWithoutSubjectsInput, ClassNameUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassNameUpdateManyWithWhereWithoutSubjectsInput = {
    where: ClassNameScalarWhereInput
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type ClassNameScalarWhereInput = {
    AND?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    OR?: ClassNameScalarWhereInput[]
    NOT?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    level?: StringFilter<"ClassName"> | string
    position?: IntFilter<"ClassName"> | number
    subjectIds?: StringNullableListFilter<"ClassName">
    chapterIds?: StringNullableListFilter<"ClassName">
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
  }

  export type ChapterUpdateManyWithWhereWithoutSubjectInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutSubjectInput>
  }

  export type McqUpsertWithWhereUniqueWithoutSubjectInput = {
    where: McqWhereUniqueInput
    update: XOR<McqUpdateWithoutSubjectInput, McqUncheckedUpdateWithoutSubjectInput>
    create: XOR<McqCreateWithoutSubjectInput, McqUncheckedCreateWithoutSubjectInput>
  }

  export type McqUpdateWithWhereUniqueWithoutSubjectInput = {
    where: McqWhereUniqueInput
    data: XOR<McqUpdateWithoutSubjectInput, McqUncheckedUpdateWithoutSubjectInput>
  }

  export type McqUpdateManyWithWhereWithoutSubjectInput = {
    where: McqScalarWhereInput
    data: XOR<McqUpdateManyMutationInput, McqUncheckedUpdateManyWithoutSubjectInput>
  }

  export type McqScalarWhereInput = {
    AND?: McqScalarWhereInput | McqScalarWhereInput[]
    OR?: McqScalarWhereInput[]
    NOT?: McqScalarWhereInput | McqScalarWhereInput[]
    id?: StringFilter<"Mcq"> | string
    question?: StringFilter<"Mcq"> | string
    options?: StringNullableListFilter<"Mcq">
    statements?: StringNullableListFilter<"Mcq">
    answer?: StringFilter<"Mcq"> | string
    type?: StringFilter<"Mcq"> | string
    reference?: StringNullableFilter<"Mcq"> | string | null
    explanation?: StringNullableFilter<"Mcq"> | string | null
    isMath?: BoolFilter<"Mcq"> | boolean
    session?: IntFilter<"Mcq"> | number
    source?: StringNullableFilter<"Mcq"> | string | null
    questionUrl?: StringNullableFilter<"Mcq"> | string | null
    contextUrl?: StringNullableFilter<"Mcq"> | string | null
    context?: StringNullableFilter<"Mcq"> | string | null
    subjectId?: StringFilter<"Mcq"> | string
    chapterId?: StringFilter<"Mcq"> | string
    examIds?: StringNullableListFilter<"Mcq">
    createdAt?: DateTimeFilter<"Mcq"> | Date | string
    updatedAt?: DateTimeFilter<"Mcq"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
    create: XOR<ExamCreateWithoutSubjectInput, ExamUncheckedCreateWithoutSubjectInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutSubjectInput, ExamUncheckedUpdateWithoutSubjectInput>
  }

  export type ExamUpdateManyWithWhereWithoutSubjectInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SubjectCreateWithoutChaptersInput = {
    id?: string
    name: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameCreateNestedManyWithoutSubjectsInput
    mcqs?: McqCreateNestedManyWithoutSubjectInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutChaptersInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameUncheckedCreateNestedManyWithoutSubjectsInput
    mcqs?: McqUncheckedCreateNestedManyWithoutSubjectInput
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutChaptersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
  }

  export type ExamCreateWithoutChaptersInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutChaptersInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutChaptersInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput>
  }

  export type ClassNameCreateWithoutChaptersInput = {
    id?: string
    name: string
    level: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectCreateNestedManyWithoutClassNamesInput
    exams?: ExamCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateWithoutChaptersInput = {
    id?: string
    name: string
    level: string
    position?: number
    subjectIds?: ClassNameCreatesubjectIdsInput | string[]
    chapterIds?: ClassNameCreatechapterIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassNamesInput
    exams?: ExamUncheckedCreateNestedManyWithoutClassNameInput
  }

  export type ClassNameCreateOrConnectWithoutChaptersInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput>
  }

  export type ChapterContextCreateWithoutChapterInput = {
    id?: string
    title: string
    author?: string | null
    authorSummary?: string | null
    content: string
    meaning?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterContextUncheckedCreateWithoutChapterInput = {
    id?: string
    title: string
    author?: string | null
    authorSummary?: string | null
    content: string
    meaning?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterContextCreateOrConnectWithoutChapterInput = {
    where: ChapterContextWhereUniqueInput
    create: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
  }

  export type McqCreateWithoutChapterInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutMcqsInput
    exams?: ExamCreateNestedManyWithoutQuestionsInput
  }

  export type McqUncheckedCreateWithoutChapterInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    subjectId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type McqCreateOrConnectWithoutChapterInput = {
    where: McqWhereUniqueInput
    create: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput>
  }

  export type McqCreateManyChapterInputEnvelope = {
    data: McqCreateManyChapterInput | McqCreateManyChapterInput[]
  }

  export type SubjectUpsertWithoutChaptersInput = {
    update: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutChaptersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type SubjectUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUpdateManyWithoutSubjectsNestedInput
    mcqs?: McqUpdateManyWithoutSubjectNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUncheckedUpdateManyWithoutSubjectsNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutSubjectNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ExamUpsertWithWhereUniqueWithoutChaptersInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutChaptersInput, ExamUncheckedUpdateWithoutChaptersInput>
    create: XOR<ExamCreateWithoutChaptersInput, ExamUncheckedCreateWithoutChaptersInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutChaptersInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutChaptersInput, ExamUncheckedUpdateWithoutChaptersInput>
  }

  export type ExamUpdateManyWithWhereWithoutChaptersInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutChaptersInput>
  }

  export type ClassNameUpsertWithWhereUniqueWithoutChaptersInput = {
    where: ClassNameWhereUniqueInput
    update: XOR<ClassNameUpdateWithoutChaptersInput, ClassNameUncheckedUpdateWithoutChaptersInput>
    create: XOR<ClassNameCreateWithoutChaptersInput, ClassNameUncheckedCreateWithoutChaptersInput>
  }

  export type ClassNameUpdateWithWhereUniqueWithoutChaptersInput = {
    where: ClassNameWhereUniqueInput
    data: XOR<ClassNameUpdateWithoutChaptersInput, ClassNameUncheckedUpdateWithoutChaptersInput>
  }

  export type ClassNameUpdateManyWithWhereWithoutChaptersInput = {
    where: ClassNameScalarWhereInput
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyWithoutChaptersInput>
  }

  export type ChapterContextUpsertWithoutChapterInput = {
    update: XOR<ChapterContextUpdateWithoutChapterInput, ChapterContextUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterContextCreateWithoutChapterInput, ChapterContextUncheckedCreateWithoutChapterInput>
    where?: ChapterContextWhereInput
  }

  export type ChapterContextUpdateToOneWithWhereWithoutChapterInput = {
    where?: ChapterContextWhereInput
    data: XOR<ChapterContextUpdateWithoutChapterInput, ChapterContextUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterContextUpdateWithoutChapterInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterContextUncheckedUpdateWithoutChapterInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    authorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    meaning?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUpsertWithWhereUniqueWithoutChapterInput = {
    where: McqWhereUniqueInput
    update: XOR<McqUpdateWithoutChapterInput, McqUncheckedUpdateWithoutChapterInput>
    create: XOR<McqCreateWithoutChapterInput, McqUncheckedCreateWithoutChapterInput>
  }

  export type McqUpdateWithWhereUniqueWithoutChapterInput = {
    where: McqWhereUniqueInput
    data: XOR<McqUpdateWithoutChapterInput, McqUncheckedUpdateWithoutChapterInput>
  }

  export type McqUpdateManyWithWhereWithoutChapterInput = {
    where: McqScalarWhereInput
    data: XOR<McqUpdateManyMutationInput, McqUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterCreateWithoutContextInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
    exams?: ExamCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameCreateNestedManyWithoutChaptersInput
    mcqs?: McqCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutContextInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameUncheckedCreateNestedManyWithoutChaptersInput
    mcqs?: McqUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutContextInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutContextInput, ChapterUncheckedCreateWithoutContextInput>
  }

  export type ChapterUpsertWithoutContextInput = {
    update: XOR<ChapterUpdateWithoutContextInput, ChapterUncheckedUpdateWithoutContextInput>
    create: XOR<ChapterCreateWithoutContextInput, ChapterUncheckedCreateWithoutContextInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutContextInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutContextInput, ChapterUncheckedUpdateWithoutContextInput>
  }

  export type ChapterUpdateWithoutContextInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    exams?: ExamUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUpdateManyWithoutChaptersNestedInput
    mcqs?: McqUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutContextInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUncheckedUpdateManyWithoutChaptersNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type SubjectCreateWithoutMcqsInput = {
    id?: string
    name: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    exams?: ExamCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutMcqsInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    exams?: ExamUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutMcqsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutMcqsInput, SubjectUncheckedCreateWithoutMcqsInput>
  }

  export type ChapterCreateWithoutMcqsInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
    exams?: ExamCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameCreateNestedManyWithoutChaptersInput
    context?: ChapterContextCreateNestedOneWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutMcqsInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutChaptersInput
    classNames?: ClassNameUncheckedCreateNestedManyWithoutChaptersInput
    context?: ChapterContextUncheckedCreateNestedOneWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutMcqsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutMcqsInput, ChapterUncheckedCreateWithoutMcqsInput>
  }

  export type ExamCreateWithoutQuestionsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type SubjectUpsertWithoutMcqsInput = {
    update: XOR<SubjectUpdateWithoutMcqsInput, SubjectUncheckedUpdateWithoutMcqsInput>
    create: XOR<SubjectCreateWithoutMcqsInput, SubjectUncheckedCreateWithoutMcqsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutMcqsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutMcqsInput, SubjectUncheckedUpdateWithoutMcqsInput>
  }

  export type SubjectUpdateWithoutMcqsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutMcqsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ChapterUpsertWithoutMcqsInput = {
    update: XOR<ChapterUpdateWithoutMcqsInput, ChapterUncheckedUpdateWithoutMcqsInput>
    create: XOR<ChapterCreateWithoutMcqsInput, ChapterUncheckedCreateWithoutMcqsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutMcqsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutMcqsInput, ChapterUncheckedUpdateWithoutMcqsInput>
  }

  export type ChapterUpdateWithoutMcqsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    exams?: ExamUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUpdateOneWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutMcqsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUncheckedUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUncheckedUpdateOneWithoutChapterNestedInput
  }

  export type ExamUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamUpdateManyWithWhereWithoutQuestionsInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type ClassNameCreateWithoutExamsInput = {
    id?: string
    name: string
    level: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectCreateNestedManyWithoutClassNamesInput
    chapters?: ChapterCreateNestedManyWithoutClassNamesInput
  }

  export type ClassNameUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    level: string
    position?: number
    subjectIds?: ClassNameCreatesubjectIdsInput | string[]
    chapterIds?: ClassNameCreatechapterIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutClassNamesInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutClassNamesInput
  }

  export type ClassNameCreateOrConnectWithoutExamsInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutExamsInput, ClassNameUncheckedCreateWithoutExamsInput>
  }

  export type SubjectCreateWithoutExamsInput = {
    id?: string
    name: string
    group?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    mcqs?: McqCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    group?: string | null
    classNameIds?: SubjectCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    mcqs?: McqUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutExamsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
  }

  export type ChapterCreateWithoutExamsInput = {
    id?: string
    name: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
    classNames?: ClassNameCreateNestedManyWithoutChaptersInput
    context?: ChapterContextCreateNestedOneWithoutChapterInput
    mcqs?: McqCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    position?: number
    subjectId: string
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    classNames?: ClassNameUncheckedCreateNestedManyWithoutChaptersInput
    context?: ChapterContextUncheckedCreateNestedOneWithoutChapterInput
    mcqs?: McqUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutExamsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput>
  }

  export type McqCreateWithoutExamsInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutMcqsInput
    chapter: ChapterCreateNestedOneWithoutMcqsInput
  }

  export type McqUncheckedCreateWithoutExamsInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    subjectId: string
    chapterId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqCreateOrConnectWithoutExamsInput = {
    where: McqWhereUniqueInput
    create: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput>
  }

  export type UserCreateWithoutExamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutExamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
  }

  export type McqAttemptCreateWithoutExamInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttemptsInput
    feedback?: ExamFeedbackCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptUncheckedCreateWithoutExamInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    feedback?: ExamFeedbackUncheckedCreateNestedOneWithoutMcqAttemptInput
  }

  export type McqAttemptCreateOrConnectWithoutExamInput = {
    where: McqAttemptWhereUniqueInput
    create: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput>
  }

  export type McqAttemptCreateManyExamInputEnvelope = {
    data: McqAttemptCreateManyExamInput | McqAttemptCreateManyExamInput[]
  }

  export type RecommendationCreateWithoutExamInput = {
    id?: string
    title: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUncheckedCreateWithoutExamInput = {
    id?: string
    title: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationCreateOrConnectWithoutExamInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput>
  }

  export type RecommendationCreateManyExamInputEnvelope = {
    data: RecommendationCreateManyExamInput | RecommendationCreateManyExamInput[]
  }

  export type ClassNameUpsertWithoutExamsInput = {
    update: XOR<ClassNameUpdateWithoutExamsInput, ClassNameUncheckedUpdateWithoutExamsInput>
    create: XOR<ClassNameCreateWithoutExamsInput, ClassNameUncheckedCreateWithoutExamsInput>
    where?: ClassNameWhereInput
  }

  export type ClassNameUpdateToOneWithWhereWithoutExamsInput = {
    where?: ClassNameWhereInput
    data: XOR<ClassNameUpdateWithoutExamsInput, ClassNameUncheckedUpdateWithoutExamsInput>
  }

  export type ClassNameUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUpdateManyWithoutClassNamesNestedInput
    chapters?: ChapterUpdateManyWithoutClassNamesNestedInput
  }

  export type ClassNameUncheckedUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutClassNamesNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutClassNamesNestedInput
  }

  export type SubjectUpsertWithoutExamsInput = {
    update: XOR<SubjectUpdateWithoutExamsInput, SubjectUncheckedUpdateWithoutExamsInput>
    create: XOR<SubjectCreateWithoutExamsInput, SubjectUncheckedCreateWithoutExamsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutExamsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutExamsInput, SubjectUncheckedUpdateWithoutExamsInput>
  }

  export type SubjectUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutExamsInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutExamsInput, ChapterUncheckedUpdateWithoutExamsInput>
    create: XOR<ChapterCreateWithoutExamsInput, ChapterUncheckedCreateWithoutExamsInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutExamsInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutExamsInput, ChapterUncheckedUpdateWithoutExamsInput>
  }

  export type ChapterUpdateManyWithWhereWithoutExamsInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutExamsInput>
  }

  export type McqUpsertWithWhereUniqueWithoutExamsInput = {
    where: McqWhereUniqueInput
    update: XOR<McqUpdateWithoutExamsInput, McqUncheckedUpdateWithoutExamsInput>
    create: XOR<McqCreateWithoutExamsInput, McqUncheckedCreateWithoutExamsInput>
  }

  export type McqUpdateWithWhereUniqueWithoutExamsInput = {
    where: McqWhereUniqueInput
    data: XOR<McqUpdateWithoutExamsInput, McqUncheckedUpdateWithoutExamsInput>
  }

  export type McqUpdateManyWithWhereWithoutExamsInput = {
    where: McqScalarWhereInput
    data: XOR<McqUpdateManyMutationInput, McqUncheckedUpdateManyWithoutExamsInput>
  }

  export type UserUpsertWithoutExamsInput = {
    update: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
  }

  export type UserUpdateWithoutExamsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutExamsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type McqAttemptUpsertWithWhereUniqueWithoutExamInput = {
    where: McqAttemptWhereUniqueInput
    update: XOR<McqAttemptUpdateWithoutExamInput, McqAttemptUncheckedUpdateWithoutExamInput>
    create: XOR<McqAttemptCreateWithoutExamInput, McqAttemptUncheckedCreateWithoutExamInput>
  }

  export type McqAttemptUpdateWithWhereUniqueWithoutExamInput = {
    where: McqAttemptWhereUniqueInput
    data: XOR<McqAttemptUpdateWithoutExamInput, McqAttemptUncheckedUpdateWithoutExamInput>
  }

  export type McqAttemptUpdateManyWithWhereWithoutExamInput = {
    where: McqAttemptScalarWhereInput
    data: XOR<McqAttemptUpdateManyMutationInput, McqAttemptUncheckedUpdateManyWithoutExamInput>
  }

  export type RecommendationUpsertWithWhereUniqueWithoutExamInput = {
    where: RecommendationWhereUniqueInput
    update: XOR<RecommendationUpdateWithoutExamInput, RecommendationUncheckedUpdateWithoutExamInput>
    create: XOR<RecommendationCreateWithoutExamInput, RecommendationUncheckedCreateWithoutExamInput>
  }

  export type RecommendationUpdateWithWhereUniqueWithoutExamInput = {
    where: RecommendationWhereUniqueInput
    data: XOR<RecommendationUpdateWithoutExamInput, RecommendationUncheckedUpdateWithoutExamInput>
  }

  export type RecommendationUpdateManyWithWhereWithoutExamInput = {
    where: RecommendationScalarWhereInput
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyWithoutExamInput>
  }

  export type RecommendationScalarWhereInput = {
    AND?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    OR?: RecommendationScalarWhereInput[]
    NOT?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    id?: StringFilter<"Recommendation"> | string
    title?: StringFilter<"Recommendation"> | string
    reason?: StringFilter<"Recommendation"> | string
    examId?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeFilter<"Recommendation"> | Date | string
  }

  export type ExamCreateWithoutAttemptsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    recommendations?: RecommendationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutAttemptsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
  }

  export type UserCreateWithoutAttemptsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutAttemptsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
  }

  export type ExamFeedbackCreateWithoutMcqAttemptInput = {
    id?: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type ExamFeedbackUncheckedCreateWithoutMcqAttemptInput = {
    id?: string
    userId: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamFeedbackCreateOrConnectWithoutMcqAttemptInput = {
    where: ExamFeedbackWhereUniqueInput
    create: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
  }

  export type ExamUpsertWithoutAttemptsInput = {
    update: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type UserUpsertWithoutAttemptsInput = {
    update: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
    create: XOR<UserCreateWithoutAttemptsInput, UserUncheckedCreateWithoutAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttemptsInput, UserUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateWithoutAttemptsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutAttemptsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type ExamFeedbackUpsertWithoutMcqAttemptInput = {
    update: XOR<ExamFeedbackUpdateWithoutMcqAttemptInput, ExamFeedbackUncheckedUpdateWithoutMcqAttemptInput>
    create: XOR<ExamFeedbackCreateWithoutMcqAttemptInput, ExamFeedbackUncheckedCreateWithoutMcqAttemptInput>
    where?: ExamFeedbackWhereInput
  }

  export type ExamFeedbackUpdateToOneWithWhereWithoutMcqAttemptInput = {
    where?: ExamFeedbackWhereInput
    data: XOR<ExamFeedbackUpdateWithoutMcqAttemptInput, ExamFeedbackUncheckedUpdateWithoutMcqAttemptInput>
  }

  export type ExamFeedbackUpdateWithoutMcqAttemptInput = {
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type ExamFeedbackUncheckedUpdateWithoutMcqAttemptInput = {
    userId?: StringFieldUpdateOperationsInput | string
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptCreateWithoutFeedbackInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutAttemptsInput
  }

  export type McqAttemptUncheckedCreateWithoutFeedbackInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    examId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqAttemptCreateOrConnectWithoutFeedbackInput = {
    where: McqAttemptWhereUniqueInput
    create: XOR<McqAttemptCreateWithoutFeedbackInput, McqAttemptUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutFeedbacksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type McqAttemptUpsertWithoutFeedbackInput = {
    update: XOR<McqAttemptUpdateWithoutFeedbackInput, McqAttemptUncheckedUpdateWithoutFeedbackInput>
    create: XOR<McqAttemptCreateWithoutFeedbackInput, McqAttemptUncheckedCreateWithoutFeedbackInput>
    where?: McqAttemptWhereInput
  }

  export type McqAttemptUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: McqAttemptWhereInput
    data: XOR<McqAttemptUpdateWithoutFeedbackInput, McqAttemptUncheckedUpdateWithoutFeedbackInput>
  }

  export type McqAttemptUpdateWithoutFeedbackInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type McqAttemptUncheckedUpdateWithoutFeedbackInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type TransactionCreateWithoutCreditPlanInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCreditPlanInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCreditPlanInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput>
  }

  export type TransactionCreateManyCreditPlanInputEnvelope = {
    data: TransactionCreateManyCreditPlanInput | TransactionCreateManyCreditPlanInput[]
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreditPlanInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreditPlanInput, TransactionUncheckedUpdateWithoutCreditPlanInput>
    create: XOR<TransactionCreateWithoutCreditPlanInput, TransactionUncheckedCreateWithoutCreditPlanInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreditPlanInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreditPlanInput, TransactionUncheckedUpdateWithoutCreditPlanInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreditPlanInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreditPlanInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type CreditPlanCreateWithoutTransactionsInput = {
    id?: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status?: string
    isPopular?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditPlanUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    credit: number
    price: number
    discount: number
    save: number
    bonus: number
    status?: string
    isPopular?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditPlanCreateOrConnectWithoutTransactionsInput = {
    where: CreditPlanWhereUniqueInput
    create: XOR<CreditPlanCreateWithoutTransactionsInput, CreditPlanUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type CreditPlanUpsertWithoutTransactionsInput = {
    update: XOR<CreditPlanUpdateWithoutTransactionsInput, CreditPlanUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CreditPlanCreateWithoutTransactionsInput, CreditPlanUncheckedCreateWithoutTransactionsInput>
    where?: CreditPlanWhereInput
  }

  export type CreditPlanUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CreditPlanWhereInput
    data: XOR<CreditPlanUpdateWithoutTransactionsInput, CreditPlanUncheckedUpdateWithoutTransactionsInput>
  }

  export type CreditPlanUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditPlanUncheckedUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    discount?: IntFieldUpdateOperationsInput | number
    save?: IntFieldUpdateOperationsInput | number
    bonus?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseCreateWithoutPlanInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPurchasesInput
  }

  export type PlanPurchaseUncheckedCreateWithoutPlanInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseCreateOrConnectWithoutPlanInput = {
    where: PlanPurchaseWhereUniqueInput
    create: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput>
  }

  export type PlanPurchaseCreateManyPlanInputEnvelope = {
    data: PlanPurchaseCreateManyPlanInput | PlanPurchaseCreateManyPlanInput[]
  }

  export type PlanPurchaseUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanPurchaseWhereUniqueInput
    update: XOR<PlanPurchaseUpdateWithoutPlanInput, PlanPurchaseUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanPurchaseCreateWithoutPlanInput, PlanPurchaseUncheckedCreateWithoutPlanInput>
  }

  export type PlanPurchaseUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanPurchaseWhereUniqueInput
    data: XOR<PlanPurchaseUpdateWithoutPlanInput, PlanPurchaseUncheckedUpdateWithoutPlanInput>
  }

  export type PlanPurchaseUpdateManyWithWhereWithoutPlanInput = {
    where: PlanPurchaseScalarWhereInput
    data: XOR<PlanPurchaseUpdateManyMutationInput, PlanPurchaseUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type ExamPlanCreateWithoutPurchasesInput = {
    id?: string
    title: string
    description: string
    credit: number
    mcqs?: number
    exams?: number
    attempts?: number
    features?: ExamPlanCreatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanCreateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamPlanUncheckedCreateWithoutPurchasesInput = {
    id?: string
    title: string
    description: string
    credit: number
    mcqs?: number
    exams?: number
    attempts?: number
    features?: ExamPlanCreatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanCreateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamPlanCreateOrConnectWithoutPurchasesInput = {
    where: ExamPlanWhereUniqueInput
    create: XOR<ExamPlanCreateWithoutPurchasesInput, ExamPlanUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type ExamPlanUpsertWithoutPurchasesInput = {
    update: XOR<ExamPlanUpdateWithoutPurchasesInput, ExamPlanUncheckedUpdateWithoutPurchasesInput>
    create: XOR<ExamPlanCreateWithoutPurchasesInput, ExamPlanUncheckedCreateWithoutPurchasesInput>
    where?: ExamPlanWhereInput
  }

  export type ExamPlanUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: ExamPlanWhereInput
    data: XOR<ExamPlanUpdateWithoutPurchasesInput, ExamPlanUncheckedUpdateWithoutPurchasesInput>
  }

  export type ExamPlanUpdateWithoutPurchasesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamPlanUncheckedUpdateWithoutPurchasesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    credit?: IntFieldUpdateOperationsInput | number
    mcqs?: IntFieldUpdateOperationsInput | number
    exams?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    features?: ExamPlanUpdatefeaturesInput | string[]
    aiFeedbackFeatures?: ExamPlanUpdateaiFeedbackFeaturesInput | string[]
    enableDownloadReport?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReferredByMeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferCreateNestedOneWithoutRefereeInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByMeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredToMe?: ReferUncheckedCreateNestedOneWithoutRefereeInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByMeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByMeInput, UserUncheckedCreateWithoutReferredByMeInput>
  }

  export type UserCreateWithoutReferredToMeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    attempts?: McqAttemptCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseCreateNestedManyWithoutUserInput
    referredByMe?: ReferCreateNestedManyWithoutRefererInput
  }

  export type UserUncheckedCreateWithoutReferredToMeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: boolean
    image?: string | null
    role?: string
    status?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: ExamFeedbackUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    purchases?: PlanPurchaseUncheckedCreateNestedManyWithoutUserInput
    referredByMe?: ReferUncheckedCreateNestedManyWithoutRefererInput
  }

  export type UserCreateOrConnectWithoutReferredToMeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredToMeInput, UserUncheckedCreateWithoutReferredToMeInput>
  }

  export type UserUpsertWithoutReferredByMeInput = {
    update: XOR<UserUpdateWithoutReferredByMeInput, UserUncheckedUpdateWithoutReferredByMeInput>
    create: XOR<UserCreateWithoutReferredByMeInput, UserUncheckedCreateWithoutReferredByMeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredByMeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredByMeInput, UserUncheckedUpdateWithoutReferredByMeInput>
  }

  export type UserUpdateWithoutReferredByMeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByMeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredToMe?: ReferUncheckedUpdateOneWithoutRefereeNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferredToMeInput = {
    update: XOR<UserUpdateWithoutReferredToMeInput, UserUncheckedUpdateWithoutReferredToMeInput>
    create: XOR<UserCreateWithoutReferredToMeInput, UserUncheckedCreateWithoutReferredToMeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredToMeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredToMeInput, UserUncheckedUpdateWithoutReferredToMeInput>
  }

  export type UserUpdateWithoutReferredToMeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUpdateManyWithoutRefererNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredToMeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: ExamFeedbackUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    purchases?: PlanPurchaseUncheckedUpdateManyWithoutUserNestedInput
    referredByMe?: ReferUncheckedUpdateManyWithoutRefererNestedInput
  }

  export type ExamCreateWithoutRecommendationsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    className: ClassNameCreateNestedOneWithoutExamsInput
    subject: SubjectCreateNestedOneWithoutExamsInput
    chapters?: ChapterCreateNestedManyWithoutExamsInput
    questions?: McqCreateNestedManyWithoutExamsInput
    user: UserCreateNestedOneWithoutExamsInput
    attempts?: McqAttemptCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutRecommendationsInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutExamsInput
    questions?: McqUncheckedCreateNestedManyWithoutExamsInput
    attempts?: McqAttemptUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutRecommendationsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutRecommendationsInput, ExamUncheckedCreateWithoutRecommendationsInput>
  }

  export type ExamUpsertWithoutRecommendationsInput = {
    update: XOR<ExamUpdateWithoutRecommendationsInput, ExamUncheckedUpdateWithoutRecommendationsInput>
    create: XOR<ExamCreateWithoutRecommendationsInput, ExamUncheckedCreateWithoutRecommendationsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutRecommendationsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutRecommendationsInput, ExamUncheckedUpdateWithoutRecommendationsInput>
  }

  export type ExamUpdateWithoutRecommendationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutRecommendationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    expiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyUserInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqAttemptCreateManyUserInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    examId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamFeedbackCreateManyUserInput = {
    id?: string
    mcqAttemptId: string
    overallSummary: string
    strengths?: ExamFeedbackCreatestrengthsInput | string[]
    weaknesses?: ExamFeedbackCreateweaknessesInput | string[]
    recommendations?: ExamFeedbackCreaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    creditPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseCreateManyUserInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    planId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferCreateManyRefererInput = {
    id?: string
    hasPurchased?: boolean
    refereeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptUpdateWithoutUserInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    feedback?: ExamFeedbackUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptUncheckedUpdateWithoutUserInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: ExamFeedbackUncheckedUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptUncheckedUpdateManyWithoutUserInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamFeedbackUpdateWithoutUserInput = {
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcqAttempt?: McqAttemptUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type ExamFeedbackUncheckedUpdateWithoutUserInput = {
    mcqAttemptId?: StringFieldUpdateOperationsInput | string
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamFeedbackUncheckedUpdateManyWithoutUserInput = {
    mcqAttemptId?: StringFieldUpdateOperationsInput | string
    overallSummary?: StringFieldUpdateOperationsInput | string
    strengths?: ExamFeedbackUpdatestrengthsInput | string[]
    weaknesses?: ExamFeedbackUpdateweaknessesInput | string[]
    recommendations?: ExamFeedbackUpdaterecommendationsInput | string[]
    detailedAnalysis?: InputJsonValue | InputJsonValue | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditPlan?: CreditPlanUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    creditPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    creditPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseUpdateWithoutUserInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: ExamPlanUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PlanPurchaseUncheckedUpdateWithoutUserInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseUncheckedUpdateManyWithoutUserInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferUpdateWithoutRefererInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferredToMeNestedInput
  }

  export type ReferUncheckedUpdateWithoutRefererInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    refereeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferUncheckedUpdateManyWithoutRefererInput = {
    hasPurchased?: BoolFieldUpdateOperationsInput | boolean
    refereeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyClassNameInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    subjectId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUpdateManyWithoutSubjectNestedInput
    exams?: ExamUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutSubjectNestedInput
    exams?: ExamUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    group?: NullableStringFieldUpdateOperationsInput | string | null
    classNameIds?: SubjectUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpdateWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    exams?: ExamUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUpdateOneWithoutChapterNestedInput
    mcqs?: McqUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUncheckedUpdateOneWithoutChapterNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutClassNamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutClassNameInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutClassNameInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutClassNameInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManySubjectInput = {
    id?: string
    name: string
    position?: number
    examIds?: ChapterCreateexamIdsInput | string[]
    classNameIds?: ChapterCreateclassNameIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type McqCreateManySubjectInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    chapterId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManySubjectInput = {
    id?: string
    title: string
    type: string
    questionCount: number
    duration: number
    status?: string
    classNameId: string
    chapterIds?: ExamCreatechapterIdsInput | string[]
    questionIds?: ExamCreatequestionIdsInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassNameUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateManyWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUpdateOneWithoutChapterNestedInput
    mcqs?: McqUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutChaptersNestedInput
    classNames?: ClassNameUncheckedUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUncheckedUpdateOneWithoutChapterNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUpdateWithoutSubjectInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutMcqsNestedInput
    exams?: ExamUpdateManyWithoutQuestionsNestedInput
  }

  export type McqUncheckedUpdateWithoutSubjectInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type McqUncheckedUpdateManyWithoutSubjectInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutSubjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutSubjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutSubjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqCreateManyChapterInput = {
    id?: string
    question: string
    options?: McqCreateoptionsInput | string[]
    statements?: McqCreatestatementsInput | string[]
    answer: string
    type: string
    reference?: string | null
    explanation?: string | null
    isMath?: boolean
    session: number
    source?: string | null
    questionUrl?: string | null
    contextUrl?: string | null
    context?: string | null
    subjectId: string
    examIds?: McqCreateexamIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    questions?: McqUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: McqUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassNameUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutClassNamesNestedInput
    exams?: ExamUncheckedUpdateManyWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateManyWithoutChaptersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectIds?: ClassNameUpdatesubjectIdsInput | string[]
    chapterIds?: ClassNameUpdatechapterIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUpdateWithoutChapterInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutMcqsNestedInput
    exams?: ExamUpdateManyWithoutQuestionsNestedInput
  }

  export type McqUncheckedUpdateWithoutChapterInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type McqUncheckedUpdateManyWithoutChapterInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    className?: ClassNameUpdateOneRequiredWithoutExamsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutExamsNestedInput
    chapters?: ChapterUpdateManyWithoutExamsNestedInput
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    attempts?: McqAttemptUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutExamsNestedInput
    attempts?: McqAttemptUncheckedUpdateManyWithoutExamNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    classNameId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterIds?: ExamUpdatechapterIdsInput | string[]
    questionIds?: ExamUpdatequestionIdsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptCreateManyExamInput = {
    id?: string
    answers?: McqAttemptCreateanswersInput | string[]
    total: number
    score?: number
    streak?: number
    longestStreak?: number
    wrongAnswer?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationCreateManyExamInput = {
    id?: string
    title: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
    classNames?: ClassNameUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUpdateOneWithoutChapterNestedInput
    mcqs?: McqUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classNames?: ClassNameUncheckedUpdateManyWithoutChaptersNestedInput
    context?: ChapterContextUncheckedUpdateOneWithoutChapterNestedInput
    mcqs?: McqUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    examIds?: ChapterUpdateexamIdsInput | string[]
    classNameIds?: ChapterUpdateclassNameIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUpdateWithoutExamsInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutMcqsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutMcqsNestedInput
  }

  export type McqUncheckedUpdateWithoutExamsInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqUncheckedUpdateManyWithoutExamsInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: McqUpdateoptionsInput | string[]
    statements?: McqUpdatestatementsInput | string[]
    answer?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    isMath?: BoolFieldUpdateOperationsInput | boolean
    session?: IntFieldUpdateOperationsInput | number
    source?: NullableStringFieldUpdateOperationsInput | string | null
    questionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contextUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    chapterId?: StringFieldUpdateOperationsInput | string
    examIds?: McqUpdateexamIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type McqAttemptUpdateWithoutExamInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttemptsNestedInput
    feedback?: ExamFeedbackUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptUncheckedUpdateWithoutExamInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: ExamFeedbackUncheckedUpdateOneWithoutMcqAttemptNestedInput
  }

  export type McqAttemptUncheckedUpdateManyWithoutExamInput = {
    answers?: McqAttemptUpdateanswersInput | string[]
    total?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    wrongAnswer?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUpdateWithoutExamInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateWithoutExamInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyWithoutExamInput = {
    title?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCreditPlanInput = {
    id?: string
    transactionId: string
    amount: number
    type: string
    method: string
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutCreditPlanInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreditPlanInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCreditPlanInput = {
    transactionId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseCreateManyPlanInput = {
    id?: string
    usedMcqs?: number
    usedExams?: number
    usedAttempts?: number
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanPurchaseUpdateWithoutPlanInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PlanPurchaseUncheckedUpdateWithoutPlanInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanPurchaseUncheckedUpdateManyWithoutPlanInput = {
    usedMcqs?: IntFieldUpdateOperationsInput | number
    usedExams?: IntFieldUpdateOperationsInput | number
    usedAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}